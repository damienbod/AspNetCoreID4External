{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, BehaviorSubject, throwError, of, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { distinctUntilChanged, switchMap, retryWhen, catchError, mergeMap, map, retry, tap, concatMap, take, timeout } from 'rxjs/operators';\nimport { KJUR, hextob64u, KEYUTIL } from 'jsrsasign-reduced';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  get(url, params) {\n    return this.http.get(url, params);\n  }\n\n  post(url, body, params) {\n    return this.http.post(url, body, params);\n  }\n\n}\n\nHttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n  return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nHttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HttpBaseService,\n  factory: HttpBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HttpBaseService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }];\n  }, null);\n})();\n\nclass ConfigurationProvider {\n  constructor() {\n    this.configsInternal = {};\n  }\n\n  hasAsLeastOneConfig() {\n    return Object.keys(this.configsInternal).length > 0;\n  }\n\n  hasManyConfigs() {\n    return Object.keys(this.configsInternal).length > 1;\n  }\n\n  setConfig(readyConfig) {\n    const {\n      configId\n    } = readyConfig;\n    this.configsInternal[configId] = readyConfig;\n  }\n\n  getOpenIDConfiguration(configId) {\n    if (!!configId) {\n      return this.configsInternal[configId] || null;\n    }\n\n    const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n    return value || null;\n  }\n\n  getAllConfigurations() {\n    return Object.values(this.configsInternal);\n  }\n\n}\n\nConfigurationProvider.ɵfac = function ConfigurationProvider_Factory(t) {\n  return new (t || ConfigurationProvider)();\n};\n\nConfigurationProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigurationProvider,\n  factory: ConfigurationProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigurationProvider, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\n\nclass DataService {\n  constructor(httpClient, configurationProvider) {\n    this.httpClient = httpClient;\n    this.configurationProvider = configurationProvider;\n  }\n\n  get(url, configId, token) {\n    const headers = this.prepareHeaders(token);\n    const params = this.prepareParams(configId);\n    return this.httpClient.get(url, {\n      headers,\n      params\n    });\n  }\n\n  post(url, body, configId, headersParams) {\n    const headers = headersParams || this.prepareHeaders();\n    const params = this.prepareParams(configId);\n    return this.httpClient.post(url, body, {\n      headers,\n      params\n    });\n  }\n\n  prepareHeaders(token) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Accept', 'application/json');\n\n    if (!!token) {\n      headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n    }\n\n    return headers;\n  }\n\n  prepareParams(configId) {\n    let params = new HttpParams();\n    const {\n      ngswBypass\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (ngswBypass) {\n      params = params.set(NGSW_CUSTOM_PARAM, '');\n    }\n\n    return params;\n  }\n\n}\n\nDataService.ɵfac = function DataService_Factory(t) {\n  return new (t || DataService)(i0.ɵɵinject(HttpBaseService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DataService,\n  factory: DataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: HttpBaseService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes;\n\n(function (EventTypes) {\n  /**\r\n   *  This only works in the AppModule Constructor\r\n   */\n  EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n  EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\n  EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\n  EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\n  EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\n  EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\n  EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\n  EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\n})(EventTypes || (EventTypes = {}));\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nclass AbstractSecurityStorage {}\n\nAbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n  return new (t || AbstractSecurityStorage)();\n};\n\nAbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractSecurityStorage,\n  factory: AbstractSecurityStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractSecurityStorage, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StoragePersistenceService {\n  constructor(oidcSecurityStorage) {\n    this.oidcSecurityStorage = oidcSecurityStorage;\n  }\n\n  read(key, configId) {\n    const storedConfig = this.oidcSecurityStorage.read(configId) || {};\n    return storedConfig[key];\n  }\n\n  write(key, value, configId) {\n    const storedConfig = this.oidcSecurityStorage.read(configId) || {};\n    storedConfig[key] = value;\n    this.oidcSecurityStorage.write(configId, storedConfig);\n  }\n\n  remove(key, configId) {\n    const storedConfig = this.oidcSecurityStorage.read(configId) || {};\n    delete storedConfig[key];\n    this.oidcSecurityStorage.write(configId, storedConfig);\n  }\n\n  clear() {\n    this.oidcSecurityStorage.clear();\n  }\n\n  resetStorageFlowData(configId) {\n    this.remove('session_state', configId);\n    this.remove('storageSilentRenewRunning', configId);\n    this.remove('codeVerifier', configId);\n    this.remove('userData', configId);\n    this.remove('storageCustomParamsAuthRequest', configId);\n    this.remove('access_token_expires_at', configId);\n    this.remove('storageCustomParamsRefresh', configId);\n    this.remove('storageCustomParamsEndSession', configId);\n  }\n\n  resetAuthStateInStorage(configId) {\n    this.remove('authzData', configId);\n    this.remove('authnResult', configId);\n  }\n\n  getAccessToken(configId) {\n    return this.read('authzData', configId);\n  }\n\n  getIdToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\n  }\n\n  getRefreshToken(configId) {\n    var _a;\n\n    return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\n  }\n\n  getAuthenticationResult(configId) {\n    return this.read('authnResult', configId);\n  }\n\n}\n\nStoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n  return new (t || StoragePersistenceService)(i0.ɵɵinject(AbstractSecurityStorage));\n};\n\nStoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoragePersistenceService,\n  factory: StoragePersistenceService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoragePersistenceService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AbstractSecurityStorage\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n  LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  logError(configId, message, ...args) {\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!!args && args.length) {\n      console.error(`[ERROR] ${configId} - ${message}`, ...args);\n    } else {\n      console.error(`[ERROR] ${configId} - ${message}`);\n    }\n  }\n\n  logWarning(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\n      return;\n    }\n\n    if (!!args && args.length) {\n      console.warn(`[WARN] ${configId} - ${message}`, ...args);\n    } else {\n      console.warn(`[WARN] ${configId} - ${message}`);\n    }\n  }\n\n  logDebug(configId, message, ...args) {\n    if (!this.logLevelIsSet(configId)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configId)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\n      return;\n    }\n\n    if (!!args && args.length) {\n      console.log(`[DEBUG] ${configId} - ${message}`, ...args);\n    } else {\n      console.log(`[DEBUG] ${configId} - ${message}`);\n    }\n  }\n\n  currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel <= logLevelToCompare;\n  }\n\n  logLevelIsSet(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (logLevel === null) {\n      return false;\n    }\n\n    if (logLevel === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  loggingIsTurnedOff(configId) {\n    const {\n      logLevel\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n    return logLevel === LogLevel.None;\n  }\n\n}\n\nLoggerService.ɵfac = function LoggerService_Factory(t) {\n  return new (t || LoggerService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoggerService,\n  factory: LoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass PublicEventsService {\n  constructor() {\n    this.notify = new ReplaySubject(1);\n  }\n  /**\r\n   * Fires a new event.\r\n   *\r\n   * @param type The event type.\r\n   * @param value The event value.\r\n   */\n\n\n  fireEvent(type, value) {\n    this.notify.next({\n      type,\n      value\n    });\n  }\n  /**\r\n   * Wires up the event notification observable.\r\n   */\n\n\n  registerForEvents() {\n    return this.notify.asObservable();\n  }\n\n}\n\nPublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n  return new (t || PublicEventsService)();\n};\n\nPublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PublicEventsService,\n  factory: PublicEventsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PublicEventsService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst PARTS_OF_TOKEN = 3;\n\nclass TokenHelperService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  getTokenExpirationDate(dataIdToken) {\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      return new Date(new Date().toUTCString());\n    }\n\n    const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    date.setUTCSeconds(dataIdToken.exp);\n    return date;\n  }\n\n  getHeaderFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 0, encoded);\n  }\n\n  getPayloadFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 1, encoded);\n  }\n\n  getSignatureFromToken(token, encoded, configId) {\n    if (!this.tokenIsValid(token, configId)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 2, encoded);\n  }\n\n  getPartOfToken(token, index, encoded) {\n    const partOfToken = this.extractPartOfToken(token, index);\n\n    if (encoded) {\n      return partOfToken;\n    }\n\n    const result = this.urlBase64Decode(partOfToken);\n    return JSON.parse(result);\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        output += '==';\n        break;\n\n      case 3:\n        output += '=';\n        break;\n\n      default:\n        throw Error('Illegal base64url string!');\n    }\n\n    const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n    try {\n      // Going backwards: from byte stream, to percent-encoding, to original string.\n      return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    } catch (err) {\n      return decoded;\n    }\n  }\n\n  tokenIsValid(token, configId) {\n    if (!token) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\n      return false;\n    }\n\n    if (!token.includes('.')) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\n      return false;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== PARTS_OF_TOKEN) {\n      this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n      return false;\n    }\n\n    return true;\n  }\n\n  extractPartOfToken(token, index) {\n    return token.split('.')[index];\n  }\n\n}\n\nTokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n  return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService));\n};\n\nTokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenHelperService,\n  factory: TokenHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass JsrsAsignReducedService {\n  generateCodeChallenge(codeVerifier) {\n    const hash = KJUR.crypto.Util.hashString(codeVerifier, 'sha256');\n    const testData = hextob64u(hash);\n    return testData;\n  }\n\n  generateAtHash(accessToken, sha) {\n    const hash = KJUR.crypto.Util.hashString(accessToken, sha);\n    const first128bits = hash.substr(0, hash.length / 2);\n    const testData = hextob64u(first128bits);\n    return testData;\n  }\n\n}\n\nJsrsAsignReducedService.ɵfac = function JsrsAsignReducedService_Factory(t) {\n  return new (t || JsrsAsignReducedService)();\n};\n\nJsrsAsignReducedService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JsrsAsignReducedService,\n  factory: JsrsAsignReducedService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JsrsAsignReducedService, [{\n    type: Injectable\n  }], null, null);\n})(); // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nclass TokenValidationService {\n  constructor(tokenHelperService, loggerService, jsrsAsignReducedService) {\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.jsrsAsignReducedService = jsrsAsignReducedService;\n    this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  hasIdTokenExpired(token, configId, offsetSeconds) {\n    const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\n    return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\n    const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (!tokenExpirationDate) {\n      return false;\n    }\n\n    const tokenExpirationValue = tokenExpirationDate.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // Token not expired?\n\n    return tokenNotExpired;\n  }\n\n  validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\n    // value is optional, so if it does not exist, then it has not expired\n    if (!accessTokenExpiresAt) {\n      return true;\n    }\n\n    offsetSeconds = offsetSeconds || 0;\n    const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n    const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n    const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`); // access token not expired?\n\n    return tokenNotExpired;\n  } // iss\n  // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n  // https scheme that contains scheme, host,\n  // and optionally, port number and path components and no query or fragment components.\n  //\n  // sub\n  // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n  // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n  // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n  //\n  // aud\n  // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n  // audience value.\n  // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n  // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n  //\n  // exp\n  // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n  // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n  // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n  // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n  // the date/ time.\n  // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n  //\n  // iat\n  // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n  // 1970- 01 - 01T00: 00: 00Z as measured\n  // in UTC until the date/ time.\n\n\n  validateRequiredIdToken(dataIdToken, configId) {\n    let validated = true;\n\n    if (!dataIdToken.hasOwnProperty('iss')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('sub')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('aud')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('exp')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      validated = false;\n      this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\n    }\n\n    return validated;\n  } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n  // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n  validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\n    if (disableIatOffsetValidation) {\n      return true;\n    }\n\n    if (!dataIdToken.hasOwnProperty('iat')) {\n      return false;\n    }\n\n    const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n    maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n    const nowInUtc = new Date(new Date().toUTCString());\n    const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n    const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n    this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n    if (diff > 0) {\n      return diff < maxOffsetAllowedInMilliseconds;\n    }\n\n    return -diff < maxOffsetAllowedInMilliseconds;\n  } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n  // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n  // The precise method for detecting replay attacks is Client specific.\n  // However the nonce claim SHOULD not be present for the refresh_token grant type\n  // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n  // The current spec is ambiguous and KeyCloak does send it.\n\n\n  validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\n    const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n    if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n      return false;\n    }\n\n    return true;\n  } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n  // MUST exactly match the value of the iss (issuer) Claim.\n\n\n  validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\n    if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n      return false;\n    }\n\n    return true;\n  } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n  // by the iss (issuer) Claim as an audience.\n  // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n  // not trusted by the Client.\n\n\n  validateIdTokenAud(dataIdToken, aud, configId) {\n    if (Array.isArray(dataIdToken.aud)) {\n      const result = dataIdToken.aud.includes(aud);\n\n      if (!result) {\n        this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    } else if (dataIdToken.aud !== aud) {\n      this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n      return false;\n    }\n\n    return true;\n  }\n\n  validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n    if (!dataIdToken) {\n      return false;\n    }\n\n    if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n      return false;\n    }\n\n    return true;\n  } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n  validateIdTokenAzpValid(dataIdToken, clientId) {\n    if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\n      return true;\n    }\n\n    if (dataIdToken.azp === clientId) {\n      return true;\n    }\n\n    return false;\n  }\n\n  validateStateFromHashCallback(state, localState, configId) {\n    if (state !== localState) {\n      this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n      return false;\n    }\n\n    return true;\n  } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n  // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n  // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n  // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n  validateSignatureIdToken(idToken, jwtkeys, configId) {\n    if (!jwtkeys || !jwtkeys.keys) {\n      return false;\n    }\n\n    const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\n\n    if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n      this.loggerService.logWarning(configId, 'id token has no header data');\n      return false;\n    }\n\n    const kid = headerData.kid;\n    const alg = headerData.alg;\n\n    if (!this.keyAlgorithms.includes(alg)) {\n      this.loggerService.logWarning(configId, 'alg not supported', alg);\n      return false;\n    }\n\n    let jwtKtyToUse = 'RSA';\n\n    if (alg.charAt(0) === 'E') {\n      jwtKtyToUse = 'EC';\n    }\n\n    let isValid = false; // No kid in the Jose header\n\n    if (!kid) {\n      let keyToValidate; // If only one key, use it\n\n      if (jwtkeys.keys.length === 1 && jwtkeys.keys[0].kty === jwtKtyToUse) {\n        keyToValidate = jwtkeys.keys[0];\n      } else {\n        // More than one key\n        // Make sure there's exactly 1 key candidate\n        // kty \"RSA\" and \"EC\" uses \"sig\"\n        let amountOfMatchingKeys = 0;\n\n        for (const key of jwtkeys.keys) {\n          if (key.kty === jwtKtyToUse && key.use === 'sig') {\n            amountOfMatchingKeys++;\n            keyToValidate = key;\n          }\n        }\n\n        if (amountOfMatchingKeys > 1) {\n          this.loggerService.logWarning(configId, 'no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\n          return false;\n        }\n      }\n\n      if (!keyToValidate) {\n        this.loggerService.logWarning(configId, 'no keys found, incorrect Signature, validation failed for id_token');\n        return false;\n      }\n\n      isValid = KJUR.jws.JWS.verify(idToken, KEYUTIL.getKey(keyToValidate), [alg]);\n\n      if (!isValid) {\n        this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\n      }\n\n      return isValid;\n    } else {\n      // kid in the Jose header of id_token\n      for (const key of jwtkeys.keys) {\n        if (key.kid === kid) {\n          const publicKey = KEYUTIL.getKey(key);\n          isValid = KJUR.jws.JWS.verify(idToken, publicKey, [alg]);\n\n          if (!isValid) {\n            this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\n          }\n\n          return isValid;\n        }\n      }\n    }\n\n    return isValid;\n  } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n  //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n  ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n  ////    if (!header_data.hasOwnProperty('kid')) {\n  ////        // no kid defined in Jose header\n  ////        if (jwtkeys.keys.length != 1) {\n  ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n  ////            return false;\n  ////        }\n  ////    }\n  ////    return true;\n  //// }\n  // Access Token Validation\n  // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n  // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n  // access_token C2: Take the left- most half of the hash and base64url- encode it.\n  // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n  // is present in the ID Token.\n\n\n  validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\n    this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n    let sha = 'sha256';\n\n    if (idTokenAlg.includes('384')) {\n      sha = 'sha384';\n    } else if (idTokenAlg.includes('512')) {\n      sha = 'sha512';\n    }\n\n    const testData = this.jsrsAsignReducedService.generateAtHash('' + accessToken, sha);\n    this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + testData);\n\n    if (testData === atHash) {\n      return true; // isValid;\n    } else {\n      const testValue = this.jsrsAsignReducedService.generateAtHash('' + decodeURIComponent(accessToken), sha);\n      this.loggerService.logDebug(configId, '-gen access--' + testValue);\n\n      if (testValue === atHash) {\n        return true; // isValid\n      }\n    }\n\n    return false;\n  }\n\n  millisToMinutesAndSeconds(millis) {\n    const minutes = Math.floor(millis / 60000);\n    const seconds = (millis % 60000 / 1000).toFixed(0);\n    return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n  }\n\n}\n\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\nTokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n  return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JsrsAsignReducedService));\n};\n\nTokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenValidationService,\n  factory: TokenValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: JsrsAsignReducedService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\n\nclass AuthStateService {\n  constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.tokenValidationService = tokenValidationService;\n    this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n  }\n\n  get authenticated$() {\n    return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n  }\n\n  setAuthenticatedAndFireEvent() {\n    const result = this.composeAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  setUnauthenticatedAndFireEvent(configIdToReset) {\n    this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\n    const result = this.composeUnAuthenticatedResult();\n    this.authenticatedInternal$.next(result);\n  }\n\n  updateAndPublishAuthState(authenticationResult) {\n    this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n  }\n\n  setAuthorizationData(accessToken, authResult, configId) {\n    this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\n    this.storagePersistenceService.write('authzData', accessToken, configId);\n    this.persistAccessTokenExpirationTime(authResult, configId);\n    this.setAuthenticatedAndFireEvent();\n  }\n\n  getAccessToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getIdToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getIdToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getRefreshToken(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getRefreshToken(configId);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getAuthenticationResult(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return null;\n    }\n\n    return this.storagePersistenceService.getAuthenticationResult(configId);\n  }\n\n  areAuthStorageTokensValid(configId) {\n    if (!this.isAuthenticated(configId)) {\n      return false;\n    }\n\n    if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\n      this.loggerService.logDebug(configId, 'persisted idToken is expired');\n      return false;\n    }\n\n    if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\n      this.loggerService.logDebug(configId, 'persisted accessToken is expired');\n      return false;\n    }\n\n    this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\n    return true;\n  }\n\n  hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds,\n      enableIdTokenExpiredValidationInRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!enableIdTokenExpiredValidationInRenew) {\n      return false;\n    }\n\n    const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\n    const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\n\n    if (idTokenExpired) {\n      this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n    }\n\n    return idTokenExpired;\n  }\n\n  hasAccessTokenExpiredIfExpiryExists(configId) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\n    const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\n    const hasExpired = !accessTokenHasNotExpired;\n\n    if (hasExpired) {\n      this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n    }\n\n    return hasExpired;\n  }\n\n  isAuthenticated(configId) {\n    return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\n  }\n\n  decodeURIComponentSafely(token) {\n    if (token) {\n      return decodeURIComponent(token);\n    } else {\n      return '';\n    }\n  }\n\n  persistAccessTokenExpirationTime(authResult, configId) {\n    if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\n      const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n      this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\n    }\n  }\n\n  composeAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: true,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: true\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  composeUnAuthenticatedResult() {\n    if (!this.configurationProvider.hasManyConfigs()) {\n      const {\n        configId\n      } = this.configurationProvider.getOpenIDConfiguration();\n      return {\n        isAuthenticated: false,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: false\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated();\n  }\n\n  checkAllConfigsIfTheyAreAuthenticated() {\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allConfigsAuthenticated = configs.map(({\n      configId\n    }) => ({\n      configId,\n      isAuthenticated: this.isAuthenticated(configId)\n    }));\n    const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n    return {\n      allConfigsAuthenticated,\n      isAuthenticated\n    };\n  }\n\n}\n\nAuthStateService.ɵfac = function AuthStateService_Factory(t) {\n  return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(TokenValidationService));\n};\n\nAuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthStateService,\n  factory: AuthStateService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthStateService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: TokenValidationService\n    }];\n  }, null);\n})();\n\nconst STORAGE_KEY = 'redirect';\n\nclass AutoLoginService {\n  constructor(storageService, router) {\n    this.storageService = storageService;\n    this.router = router;\n  }\n\n  checkSavedRedirectRouteAndNavigate(configId) {\n    const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\n\n    if (savedRouteForRedirect) {\n      this.deleteStoredRedirectRoute(configId);\n      this.router.navigateByUrl(savedRouteForRedirect);\n    }\n  }\n  /**\r\n   * Saves the redirect url to storage.\r\n   *\r\n   * @param url The redirect url to save.\r\n   */\n\n\n  saveRedirectRoute(configId, url) {\n    this.storageService.write(STORAGE_KEY, url, configId);\n  }\n  /**\r\n   * Gets the stored redirect route from storage.\r\n   */\n\n\n  getStoredRedirectRoute(configId) {\n    return this.storageService.read(STORAGE_KEY, configId);\n  }\n  /**\r\n   * Removes the redirect url from storage.\r\n   */\n\n\n  deleteStoredRedirectRoute(configId) {\n    this.storageService.remove(STORAGE_KEY, configId);\n  }\n\n}\n\nAutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n  return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginService,\n  factory: AutoLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nclass RandomService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  createRandom(requiredLength, configId) {\n    if (requiredLength <= 0) {\n      return '';\n    }\n\n    if (requiredLength > 0 && requiredLength < 7) {\n      this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n      requiredLength = 10;\n    }\n\n    const length = requiredLength - 6;\n    const arr = new Uint8Array(Math.floor((length || length) / 2));\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(arr);\n    }\n\n    return Array.from(arr, this.toHex).join('') + this.randomString(7);\n  }\n\n  toHex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n  }\n\n  randomString(length) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = new Uint32Array(length);\n\n    if (this.getCrypto()) {\n      this.getCrypto().getRandomValues(values);\n\n      for (let i = 0; i < length; i++) {\n        result += characters[values[i] % characters.length];\n      }\n    }\n\n    return result;\n  }\n\n  getCrypto() {\n    // support for IE,  (window.crypto || window.msCrypto)\n    return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n  }\n\n}\n\nRandomService.ɵfac = function RandomService_Factory(t) {\n  return new (t || RandomService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nRandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RandomService,\n  factory: RandomService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RandomService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowsDataService {\n  constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.randomService = randomService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n  }\n\n  createNonce(configId) {\n    const nonce = this.randomService.createRandom(40, configId);\n    this.setNonce(nonce, configId);\n    return nonce;\n  }\n\n  setNonce(nonce, configId) {\n    this.storagePersistenceService.write('authNonce', nonce, configId);\n  }\n\n  getAuthStateControl(configId) {\n    return this.storagePersistenceService.read('authStateControl', configId);\n  }\n\n  setAuthStateControl(authStateControl, configId) {\n    this.storagePersistenceService.write('authStateControl', authStateControl, configId);\n  }\n\n  getExistingOrCreateAuthStateControl(configId) {\n    let state = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!state) {\n      state = this.randomService.createRandom(40, configId);\n      this.storagePersistenceService.write('authStateControl', state, configId);\n    }\n\n    return state;\n  }\n\n  setSessionState(sessionState, configId) {\n    this.storagePersistenceService.write('session_state', sessionState, configId);\n  }\n\n  resetStorageFlowData(configId) {\n    this.storagePersistenceService.resetStorageFlowData(configId);\n  }\n\n  getCodeVerifier(configId) {\n    return this.storagePersistenceService.read('codeVerifier', configId);\n  }\n\n  createCodeVerifier(configId) {\n    const codeVerifier = this.randomService.createRandom(67, configId);\n    this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\n    return codeVerifier;\n  }\n\n  isSilentRenewRunning(configId) {\n    const storageObject = this.getSilentRenewRunningStorageEntry(configId);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n    const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n    const currentDateUtc = Date.parse(new Date().toISOString());\n    const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n    const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n    if (isProbablyStuck) {\n      this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\n      this.resetSilentRenewRunning(configId);\n      return false;\n    }\n\n    return storageObject.state === 'running';\n  }\n\n  setSilentRenewRunning(configId) {\n    const storageObject = {\n      state: 'running',\n      dateOfLaunchedProcessUtc: new Date().toISOString()\n    };\n    this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\n  }\n\n  resetSilentRenewRunning(configId) {\n    this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\n  }\n\n  getSilentRenewRunningStorageEntry(configId) {\n    const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n}\n\nFlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n  return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nFlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsDataService,\n  factory: FlowsDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: RandomService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowHelper {\n  constructor(configurationProvider) {\n    this.configurationProvider = configurationProvider;\n  }\n\n  isCurrentFlowCodeFlow(configId) {\n    return this.currentFlowIs('code', configId);\n  }\n\n  isCurrentFlowAnyImplicitFlow(configId) {\n    return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\n  }\n\n  isCurrentFlowCodeFlowWithRefreshTokens(configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isCurrentFlowImplicitFlowWithAccessToken(configId) {\n    return this.currentFlowIs('id_token token', configId);\n  }\n\n  currentFlowIs(flowTypes, configId) {\n    const {\n      responseType\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (Array.isArray(flowTypes)) {\n      return flowTypes.some(x => responseType === x);\n    }\n\n    return responseType === flowTypes;\n  }\n\n  isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\n    return this.currentFlowIs('id_token', configId);\n  }\n\n}\n\nFlowHelper.ɵfac = function FlowHelper_Factory(t) {\n  return new (t || FlowHelper)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nFlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowHelper,\n  factory: FlowHelper.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowHelper, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\n\nclass UrlService {\n  constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jsrsAsignReducedService) {\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.flowHelper = flowHelper;\n    this.storagePersistenceService = storagePersistenceService;\n    this.jsrsAsignReducedService = jsrsAsignReducedService;\n  }\n\n  getUrlParameter(urlToCheck, name) {\n    if (!urlToCheck) {\n      return '';\n    }\n\n    if (!name) {\n      return '';\n    }\n\n    name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\n    const results = regex.exec(urlToCheck);\n    return results === null ? '' : decodeURIComponent(results[1]);\n  }\n\n  isCallbackFromSts(currentUrl) {\n    return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n  }\n\n  getRefreshSessionSilentRenewUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\n    }\n\n    return this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '';\n  }\n\n  getAuthorizeParUrl(requestUri, configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize url when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('request_uri', requestUri);\n    params = params.append('client_id', clientId);\n    return `${authorizationUrl}?${params}`;\n  }\n\n  getAuthorizeUrl(configId, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return this.createUrlCodeFlowAuthorize(configId, customParams);\n    }\n\n    return this.createUrlImplicitFlowAuthorize(configId, customParams) || '';\n  }\n\n  createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\n\n    if (!endSessionEndpoint) {\n      return null;\n    }\n\n    const urlParts = endSessionEndpoint.split('?');\n    const authorizationEndSessionUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('id_token_hint', idTokenHint);\n    const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\n\n    if (postLogoutRedirectUri) {\n      params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (customParamsEndSession) {\n      params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\n    }\n\n    return `${authorizationEndSessionUrl}?${params}`;\n  }\n\n  createRevocationEndpointBodyAccessToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'access_token');\n    return params.toString();\n  }\n\n  createRevocationEndpointBodyRefreshToken(token, configId) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'refresh_token');\n    return params.toString();\n  }\n\n  getRevocationEndpointUrl(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\n\n    if (!revocationEndpoint) {\n      return null;\n    }\n\n    const urlParts = revocationEndpoint.split('?');\n    const revocationEndpointUrl = urlParts[0];\n    return revocationEndpointUrl;\n  }\n\n  createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\n    const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\n\n    if (!codeVerifier) {\n      this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\n      return null;\n    }\n\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'authorization_code');\n    params = params.set('client_id', clientId);\n    params = params.set('code_verifier', codeVerifier);\n    params = params.set('code', code);\n\n    if (customTokenParams) {\n      params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\n    }\n\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\n      params = params.set('redirect_uri', silentRenewUrl);\n      return params.toString();\n    }\n\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    params = params.set('redirect_uri', redirectUrl);\n    return params.toString();\n  }\n\n  createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\n    const clientId = this.getClientId(configId);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'refresh_token');\n    params = params.set('client_id', clientId);\n    params = params.set('refresh_token', refreshToken);\n\n    if (customParamsRefresh) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\n    }\n\n    return params.toString();\n  }\n\n  createBodyForParCodeFlowRequest(configId, customParamsRequest) {\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    let params = this.createHttpParams('');\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n    params = params.append('code_challenge', codeChallenge);\n    params = params.append('code_challenge_method', 'S256');\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    if (customParamsAuthRequest) {\n      params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\n    }\n\n    if (customParamsRequest) {\n      params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\n    }\n\n    return params.toString();\n  }\n\n  createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configId, `Can not create an authorize url when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    if (!responseType) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n      return null;\n    }\n\n    if (!scope) {\n      this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n    }\n\n    if (prompt) {\n      params = params.append('prompt', prompt);\n    }\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\n\n    if (Object.keys(mergedParams).length > 0) {\n      params = this.appendCustomParams(Object.assign({}, mergedParams), params);\n    }\n\n    return `${authorizationUrl}?${params}`;\n  }\n\n  createUrlImplicitFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowWithSilentRenew(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const silentRenewUrl = this.getSilentRenewUrl(configId);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\n    }\n\n    this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlImplicitFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowAuthorize(configId, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    const nonce = this.flowsDataService.createNonce(configId);\n    this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configId);\n\n    if (!redirectUrl) {\n      return null;\n    } // code_challenge with \"S256\"\n\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\n    const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\n    }\n\n    this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  getRedirectUrl(configId) {\n    const {\n      redirectUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!redirectUrl) {\n      this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\n      null;\n    }\n\n    return redirectUrl;\n  }\n\n  getSilentRenewUrl(configId) {\n    const {\n      silentRenewUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!silentRenewUrl) {\n      this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\n      return null;\n    }\n\n    return silentRenewUrl;\n  }\n\n  getPostLogoutRedirectUrl(configId) {\n    const {\n      postLogoutRedirectUri\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!postLogoutRedirectUri) {\n      this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n      return null;\n    }\n\n    return postLogoutRedirectUri;\n  }\n\n  getClientId(configId) {\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!clientId) {\n      this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\n      return null;\n    }\n\n    return clientId;\n  }\n\n  appendCustomParams(customParams, params) {\n    for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\n      params = params.append(key, value.toString());\n    }\n\n    return params;\n  }\n\n  createHttpParams(existingParams) {\n    existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\n    const params = new HttpParams({\n      fromString: existingParams,\n      encoder: new UriEncoder()\n    });\n    return params;\n  }\n\n}\n\nUrlService.ɵfac = function UrlService_Factory(t) {\n  return new (t || UrlService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JsrsAsignReducedService));\n};\n\nUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlService,\n  factory: UrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: JsrsAsignReducedService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackHandlerService {\n  constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.tokenValidationService = tokenValidationService;\n    this.flowsDataService = flowsDataService;\n    this.configurationProvider = configurationProvider;\n    this.storagePersistenceService = storagePersistenceService;\n    this.dataService = dataService;\n  } // STEP 1 Code Flow\n\n\n  codeFlowCallback(urlToCheck, configId) {\n    const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n    const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n    const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state') || null;\n\n    if (!state) {\n      this.loggerService.logDebug(configId, 'no state in url');\n      return throwError('no state in url');\n    }\n\n    if (!code) {\n      this.loggerService.logDebug(configId, 'no code in url');\n      return throwError('no code in url');\n    }\n\n    this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\n    const initialCallbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: false,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(initialCallbackContext);\n  } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n  codeFlowCodeRequest(callbackContext, configId) {\n    const authStateControl = this.flowsDataService.getAuthStateControl(configId);\n    const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\n\n    if (!isStateCorrect) {\n      return throwError('codeFlowCodeRequest incorrect state');\n    }\n\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError('Token Endpoint not defined');\n    }\n\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\n    return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap(response => {\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      authResult.session_state = callbackContext.sessionState;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nCodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n  return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n};\n\nCodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackHandlerService,\n  factory: CodeFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\n\nclass UserService {\n  constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\n    this.oidcDataService = oidcDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.eventService = eventService;\n    this.loggerService = loggerService;\n    this.tokenHelperService = tokenHelperService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n  }\n\n  get userData$() {\n    return this.userDataInternal$.asObservable();\n  }\n\n  getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\n    idToken = idToken || this.storagePersistenceService.getIdToken(configId);\n    decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\n    const existingUserDataFromStorage = this.getUserDataFromStore(configId);\n    const haveUserData = !!existingUserDataFromStorage;\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n    const accessToken = this.storagePersistenceService.getAccessToken(configId);\n\n    if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n      this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\n      this.setUserDataToStore(decodedIdToken, configId);\n      return of(decodedIdToken);\n    }\n\n    const {\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n      return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap(userData => {\n        this.loggerService.logDebug(configId, 'Received user data: ', userData);\n\n        if (!!userData) {\n          this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\n          return of(userData);\n        } else {\n          return throwError('Received no user data, request failed');\n        }\n      }));\n    }\n\n    return of(existingUserDataFromStorage);\n  }\n\n  getUserDataFromStore(configId) {\n    return this.storagePersistenceService.read('userData', configId) || null;\n  }\n\n  publishUserDataIfExists(configId) {\n    const userData = this.getUserDataFromStore(configId);\n\n    if (userData) {\n      this.fireUserDataEvent(configId, userData);\n    }\n  }\n\n  setUserDataToStore(userData, configId) {\n    this.storagePersistenceService.write('userData', userData, configId);\n    this.fireUserDataEvent(configId, userData);\n  }\n\n  resetUserDataInStore(configId) {\n    this.storagePersistenceService.remove('userData', configId);\n    this.fireUserDataEvent(configId, null);\n  }\n\n  getUserDataOidcFlowAndSave(idTokenSub, configId) {\n    return this.getIdentityUserData(configId).pipe(map(data => {\n      if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\n        this.setUserDataToStore(data, configId);\n        return data;\n      } else {\n        // something went wrong, user data sub does not match that from id_token\n        this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\n        this.resetUserDataInStore(configId);\n        return null;\n      }\n    }));\n  }\n\n  getIdentityUserData(configId) {\n    const token = this.storagePersistenceService.getAccessToken(configId);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\n      return throwError('authWellKnownEndpoints is undefined');\n    }\n\n    const userInfoEndpoint = authWellKnownEndPoints.userinfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n      return throwError('authWellKnownEndpoints.userinfo_endpoint is undefined');\n    }\n\n    return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\n  }\n\n  validateUserDataSubIdToken(idTokenSub, userDataSub) {\n    if (!idTokenSub) {\n      return false;\n    }\n\n    if (!userDataSub) {\n      return false;\n    }\n\n    if (idTokenSub !== userDataSub) {\n      this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n      return false;\n    }\n\n    return true;\n  }\n\n  fireUserDataEvent(configId, passedUserData) {\n    const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\n    this.userDataInternal$.next(userData);\n    this.eventService.fireEvent(EventTypes.UserDataChanged, {\n      configId,\n      userData: passedUserData\n    });\n  }\n\n  composeSingleOrMultipleUserDataObject(configId, passedUserData) {\n    const hasManyConfigs = this.configurationProvider.hasManyConfigs();\n\n    if (!hasManyConfigs) {\n      return this.composeSingleUserDataResult(configId, passedUserData);\n    }\n\n    const configs = this.configurationProvider.getAllConfigurations();\n    const allUserData = configs.map(config => {\n      if (this.currentConfigIsToUpdate(configId, config)) {\n        return {\n          configId: config.configId,\n          userData: passedUserData\n        };\n      }\n\n      const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\n      return {\n        configId: config.configId,\n        userData: alreadySavedUserData\n      };\n    });\n    return {\n      userData: null,\n      allUserData\n    };\n  }\n\n  composeSingleUserDataResult(configId, userData) {\n    return {\n      userData,\n      allUserData: [{\n        configId,\n        userData\n      }]\n    };\n  }\n\n  currentConfigIsToUpdate(configId, config) {\n    return config.configId === configId;\n  }\n\n}\n\nUserService.ɵfac = function UserService_Factory(t) {\n  return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider));\n};\n\nUserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserService,\n  factory: UserService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResetAuthDataService {\n  constructor(authStateService, flowsDataService, userService) {\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n  }\n\n  resetAuthorizationData(configId) {\n    this.userService.resetUserDataInStore(configId);\n    this.flowsDataService.resetStorageFlowData(configId);\n    this.authStateService.setUnauthenticatedAndFireEvent(configId);\n  }\n\n}\n\nResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n  return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService));\n};\n\nResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResetAuthDataService,\n  factory: ResetAuthDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResetAuthDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackHandlerService {\n  constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.doc = doc;\n  } // STEP 1 Code Flow\n  // STEP 1 Implicit Flow\n\n\n  implicitFlowCallback(configId, hash) {\n    const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\n\n    if (!isRenewProcessData) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n    }\n\n    hash = hash || this.doc.location.hash.substr(1);\n    const authResult = hash.split('&').reduce((resultData, item) => {\n      const parts = item.split('=');\n      resultData[parts.shift()] = parts.join('=');\n      return resultData;\n    }, {});\n    const callbackContext = {\n      code: null,\n      refreshToken: null,\n      state: null,\n      sessionState: null,\n      authResult,\n      isRenewProcess: isRenewProcessData,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(callbackContext);\n  }\n\n}\n\nImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n  return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackHandlerService,\n  factory: ImplicitFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n/* eslint-disable no-shadow */\n\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[\"NotSet\"] = \"NotSet\";\n  ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n  ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n  ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n  ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n  ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n  ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n  ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n  ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n  ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n  ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n  ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n  ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n  ValidationResult[\"Ok\"] = \"Ok\";\n  ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n  ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\n  constructor(storagePersistenceService, loggerService, dataService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n  }\n\n  getSigningKeys(configId) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\n\n    if (!jwksUri) {\n      const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n      this.loggerService.logWarning(configId, error);\n      return throwError(error);\n    }\n\n    this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\n    return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, configId)));\n  }\n\n  handleErrorGetSigningKeys(errorResponse, configId) {\n    let errMsg = '';\n\n    if (errorResponse instanceof HttpResponse) {\n      const body = errorResponse.body || {};\n      const err = JSON.stringify(body);\n      const {\n        status,\n        statusText\n      } = errorResponse;\n      errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n    } else {\n      const {\n        message\n      } = errorResponse;\n      errMsg = !!message ? message : `${errorResponse}`;\n    }\n\n    this.loggerService.logError(configId, errMsg);\n    return throwError(errMsg);\n  }\n\n}\n\nSigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n  return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n};\n\nSigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SigninKeyDataService,\n  factory: SigninKeyDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SigninKeyDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst JWT_KEYS = 'jwtKeys';\n\nclass HistoryJwtKeysCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.signInKeyDataService = signInKeyDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n  callbackHistoryAndResetJwtKeys(callbackContext, configId) {\n    this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\n\n    if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\n      this.resetBrowserHistory();\n    } else {\n      this.loggerService.logDebug(configId, 'history clean up inactive');\n    }\n\n    if (callbackContext.authResult.error) {\n      const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n      this.loggerService.logDebug(configId, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n    return this.signInKeyDataService.getSigningKeys(configId).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, configId)), catchError(err => {\n      // fallback: try to load jwtKeys from storage\n      const storedJwtKeys = this.readSigningKeys(configId);\n\n      if (!!storedJwtKeys) {\n        this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\n        return of(storedJwtKeys);\n      }\n\n      return throwError(err);\n    }), switchMap(jwtKeys => {\n      if (jwtKeys) {\n        callbackContext.jwtKeys = jwtKeys;\n        return of(callbackContext);\n      }\n\n      const errorMessage = `Failed to retrieve signing key`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleResultErrorFromCallback(result, isRenewProcess) {\n    let validationResult = ValidationResult.SecureTokenServerError;\n\n    if (result.error === 'login_required') {\n      validationResult = ValidationResult.LoginRequired;\n    }\n\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult,\n      isRenewProcess\n    });\n  }\n\n  historyCleanUpTurnedOn(configId) {\n    const {\n      historyCleanupOff\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !historyCleanupOff;\n  }\n\n  resetBrowserHistory() {\n    window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\n  }\n\n  storeSigningKeys(jwtKeys, configId) {\n    this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\n  }\n\n  readSigningKeys(configId) {\n    return this.storagePersistenceService.read(JWT_KEYS, configId);\n  }\n\n}\n\nHistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n  return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nHistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HistoryJwtKeysCallbackHandlerService,\n  factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryJwtKeysCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: SigninKeyDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass UserCallbackHandlerService {\n  constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 5 userData\n\n\n  callbackUser(callbackContext, configId) {\n    const {\n      isRenewProcess,\n      validationResult,\n      authResult,\n      refreshToken\n    } = callbackContext;\n    const {\n      autoUserInfo,\n      renewUserInfoAfterTokenRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!autoUserInfo) {\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n        // userData is set to the id_token decoded, auto get user data set to false\n        if (validationResult.decodedIdToken) {\n          this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\n        }\n      }\n\n      if (!isRenewProcess && !refreshToken) {\n        this.flowsDataService.setSessionState(authResult.session_state, configId);\n      }\n\n      this.publishAuthState(validationResult, isRenewProcess);\n      return of(callbackContext);\n    }\n\n    return this.userService.getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n      if (!!userData) {\n        if (!refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configId);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      } else {\n        this.resetAuthDataService.resetAuthorizationData(configId);\n        this.publishUnauthenticatedState(validationResult, isRenewProcess);\n        const errorMessage = `Called for userData but they were ${userData}`;\n        this.loggerService.logWarning(configId, errorMessage);\n        return throwError(errorMessage);\n      }\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      return throwError(errorMessage);\n    }));\n  }\n\n  publishAuthState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: true,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n  publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nUserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n  return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nUserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserCallbackHandlerService,\n  factory: UserCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {}, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nclass EqualityService {\n  isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n    if (this.isNullOrUndefined(value1)) {\n      return false;\n    }\n\n    if (this.isNullOrUndefined(value2)) {\n      return false;\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      return false;\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysHaveEqualContent(value1, value2);\n    }\n\n    return false;\n  }\n\n  areEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysStrictEqual(value1, value2);\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreObjects(value1, value2)) {\n      return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      if (Array.isArray(value1) && this.valueIsString(value2)) {\n        return value1[0] === value2;\n      }\n\n      if (Array.isArray(value2) && this.valueIsString(value1)) {\n        return value2[0] === value1;\n      }\n    }\n\n    return false;\n  }\n\n  oneValueIsStringAndTheOtherIsArray(value1, value2) {\n    return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n  }\n\n  bothValuesAreObjects(value1, value2) {\n    return this.valueIsObject(value1) && this.valueIsObject(value2);\n  }\n\n  bothValuesAreStrings(value1, value2) {\n    return this.valueIsString(value1) && this.valueIsString(value2);\n  }\n\n  bothValuesAreArrays(value1, value2) {\n    return Array.isArray(value1) && Array.isArray(value2);\n  }\n\n  valueIsString(value) {\n    return typeof value === 'string' || value instanceof String;\n  }\n\n  valueIsObject(value) {\n    return typeof value === 'object';\n  }\n\n  arraysStrictEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (let i = arr1.length; i--;) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  arraysHaveEqualContent(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.some(v => arr2.includes(v));\n  }\n\n  isNullOrUndefined(val) {\n    return val === null || val === undefined;\n  }\n\n}\n\nEqualityService.ɵfac = function EqualityService_Factory(t) {\n  return new (t || EqualityService)();\n};\n\nEqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EqualityService,\n  factory: EqualityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EqualityService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StateValidationService {\n  constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.tokenValidationService = tokenValidationService;\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.equalityService = equalityService;\n    this.flowHelper = flowHelper;\n  }\n\n  getValidatedStateResult(callbackContext, configId) {\n    if (!callbackContext) {\n      return new StateValidationResult('', '', false, {});\n    }\n\n    if (callbackContext.authResult.error) {\n      return new StateValidationResult('', '', false, {});\n    }\n\n    return this.validateState(callbackContext, configId);\n  }\n\n  validateState(callbackContext, configId) {\n    const toReturn = new StateValidationResult();\n    const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\n\n    if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\n      this.loggerService.logWarning(configId, 'authCallback incorrect state');\n      toReturn.state = ValidationResult.StatesDoNotMatch;\n      this.handleUnsuccessfulValidation(configId);\n      return toReturn;\n    }\n\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n      toReturn.accessToken = callbackContext.authResult.access_token;\n    }\n\n    if (callbackContext.authResult.id_token) {\n      const {\n        clientId,\n        issValidationOff,\n        maxIdTokenIatOffsetAllowedInSeconds,\n        disableIatOffsetValidation,\n        ignoreNonceAfterRefresh\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      toReturn.idToken = callbackContext.authResult.id_token;\n      toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\n\n      if (!this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId)) {\n        this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\n        toReturn.state = ValidationResult.SignatureFailed;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      const authNonce = this.storagePersistenceService.read('authNonce', configId);\n\n      if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect nonce');\n        toReturn.state = ValidationResult.IncorrectNonce;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\n        this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n        toReturn.state = ValidationResult.RequiredPropertyMissing;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n        toReturn.state = ValidationResult.MaxOffsetExpired;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n      if (authWellKnownEndPoints) {\n        if (issValidationOff) {\n          this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\n        } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\n          this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n          toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n          this.handleUnsuccessfulValidation(configId);\n          return toReturn;\n        }\n      } else {\n        this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\n        toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect aud');\n        toReturn.state = ValidationResult.IncorrectAud;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n        this.loggerService.logWarning(configId, 'authCallback missing azp');\n        toReturn.state = ValidationResult.IncorrectAzp;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect azp');\n        toReturn.state = ValidationResult.IncorrectAzp;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\n        toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n\n      if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\n        this.loggerService.logWarning(configId, 'authCallback id token expired');\n        toReturn.state = ValidationResult.TokenExpired;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n    } else {\n      this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\n    } // flow id_token\n\n\n    if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configId);\n      this.handleUnsuccessfulValidation(configId);\n      return toReturn;\n    } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n    if (callbackContext.authResult.id_token) {\n      const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId); // The at_hash is optional for the code flow\n\n      if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n        this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n      } else if (!this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RSA256'\n      configId) || !toReturn.accessToken) {\n        this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\n        toReturn.state = ValidationResult.IncorrectAtHash;\n        this.handleUnsuccessfulValidation(configId);\n        return toReturn;\n      }\n    }\n\n    toReturn.authResponseIsValid = true;\n    toReturn.state = ValidationResult.Ok;\n    this.handleSuccessfulValidation(configId);\n    return toReturn;\n  }\n\n  isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\n    const {\n      useRefreshToken,\n      disableRefreshIdTokenAuthTimeValidation\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!useRefreshToken) {\n      return true;\n    }\n\n    if (!callbackContext.existingIdToken) {\n      return true;\n    }\n\n    const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n    // except that it might not contain an id_token.\n    // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n    // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n    if (decodedIdToken.iss !== newIdToken.iss) {\n      this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n      return false;\n    } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n    //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n    // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n    if (decodedIdToken.azp !== newIdToken.azp) {\n      this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n      return false;\n    } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (decodedIdToken.sub !== newIdToken.sub) {\n      this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n      return false;\n    } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\n      this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\n      return false;\n    }\n\n    if (disableRefreshIdTokenAuthTimeValidation) {\n      return true;\n    } // its iat Claim MUST represent the time that the new ID Token is issued,\n    // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n    // - not the time that the new ID token is issued,\n\n\n    if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n      this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  handleSuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\n  }\n\n  handleUnsuccessfulValidation(configId) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.storagePersistenceService.write('authNonce', null, configId);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configId);\n    }\n\n    this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\n  }\n\n}\n\nStateValidationService.ɵfac = function StateValidationService_Factory(t) {\n  return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n};\n\nStateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationService,\n  factory: StateValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: EqualityService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass StateValidationCallbackHandlerService {\n  constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\n    this.loggerService = loggerService;\n    this.stateValidationService = stateValidationService;\n    this.authStateService = authStateService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.doc = doc;\n  } // STEP 4 All flows\n\n\n  callbackStateValidation(callbackContext, configId) {\n    const validationResult = this.stateValidationService.getValidatedStateResult(callbackContext, configId);\n    callbackContext.validationResult = validationResult;\n\n    if (validationResult.authResponseIsValid) {\n      this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\n      return of(callbackContext);\n    } else {\n      const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\n      this.loggerService.logWarning(configId, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n      return throwError(errorMessage);\n    }\n  }\n\n  publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nStateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n  return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nStateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationCallbackHandlerService,\n  factory: StateValidationCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: StateValidationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass RefreshSessionCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n  } // STEP 1 Refresh session\n\n\n  refreshSessionWithRefreshTokens(configId) {\n    const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\n    this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\n    const refreshToken = this.authStateService.getRefreshToken(configId);\n    const idToken = this.authStateService.getIdToken(configId);\n\n    if (refreshToken) {\n      const callbackContext = {\n        code: null,\n        refreshToken,\n        state: stateData,\n        sessionState: null,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: idToken\n      };\n      this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n      this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\n      return of(callbackContext);\n    } else {\n      const errorMessage = 'no refresh token found, please login';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n  }\n\n}\n\nRefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n  return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n};\n\nRefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionCallbackHandlerService,\n  factory: RefreshSessionCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass RefreshTokenCallbackHandlerService {\n  constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  } // STEP 2 Refresh Token\n\n\n  refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError('Token Endpoint not defined');\n    }\n\n    const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\n    return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap(response => {\n      this.loggerService.logDebug(configId, 'token refresh response: ', response);\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, configId)), catchError(error => {\n      const {\n        authority\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n  handleRefreshRetry(errors, configId) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = this.configurationProvider.getOpenIDConfiguration(configId);\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(configId, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nRefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n  return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nRefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshTokenCallbackHandlerService,\n  factory: RefreshTokenCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshTokenCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass FlowsService {\n  constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n    this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n    this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n    this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n    this.userHandlerService = userHandlerService;\n    this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n    this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n    this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n  }\n\n  processCodeFlowCallback(urlToCheck, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processSilentRenewCodeFlowCallback(firstContext, configId) {\n    return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processImplicitFlowCallback(configId, hash) {\n    return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n  processRefreshToken(configId, customParamsRefresh) {\n    return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, configId)));\n  }\n\n}\n\nFlowsService.ɵfac = function FlowsService_Factory(t) {\n  return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n};\n\nFlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsService,\n  factory: FlowsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CodeFlowCallbackHandlerService\n    }, {\n      type: ImplicitFlowCallbackHandlerService\n    }, {\n      type: HistoryJwtKeysCallbackHandlerService\n    }, {\n      type: UserCallbackHandlerService\n    }, {\n      type: StateValidationCallbackHandlerService\n    }, {\n      type: RefreshSessionCallbackHandlerService\n    }, {\n      type: RefreshTokenCallbackHandlerService\n    }];\n  }, null);\n})();\n\nclass IntervalService {\n  constructor(zone) {\n    this.zone = zone;\n    this.runTokenValidationRunning = null;\n  }\n\n  stopPeriodicTokenCheck() {\n    if (this.runTokenValidationRunning) {\n      this.runTokenValidationRunning.unsubscribe();\n      this.runTokenValidationRunning = null;\n    }\n  }\n\n  startPeriodicTokenCheck(repeatAfterSeconds) {\n    const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n    return new Observable(subscriber => {\n      let intervalId;\n      this.zone.runOutsideAngular(() => {\n        intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n      });\n      return () => {\n        clearInterval(intervalId);\n      };\n    });\n  }\n\n}\n\nIntervalService.ɵfac = function IntervalService_Factory(t) {\n  return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n};\n\nIntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IntervalService,\n  factory: IntervalService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IntervalService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackService {\n  constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\n    this.flowsService = flowsService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n  }\n\n  authenticatedImplicitFlowCallback(configId, hash) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n  return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n};\n\nImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackService,\n  factory: ImplicitFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass IFrameService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  getExistingIFrame(identifier) {\n    const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnParent)) {\n      return iFrameOnParent;\n    }\n\n    const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnSelf)) {\n      return iFrameOnSelf;\n    }\n\n    return null;\n  }\n\n  addIFrameToWindowBody(identifier, configId) {\n    const sessionIframe = this.doc.createElement('iframe');\n    sessionIframe.id = identifier;\n    sessionIframe.title = identifier;\n    this.loggerService.logDebug(configId, sessionIframe);\n    sessionIframe.style.display = 'none';\n    this.doc.body.appendChild(sessionIframe);\n    return sessionIframe;\n  }\n\n  getIFrameFromParentWindow(identifier) {\n    try {\n      const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getIFrameFromWindow(identifier) {\n    const iFrameElement = this.doc.getElementById(identifier);\n\n    if (this.isIFrameElement(iFrameElement)) {\n      return iFrameElement;\n    }\n\n    return null;\n  }\n\n  isIFrameElement(element) {\n    return !!element && element instanceof HTMLIFrameElement;\n  }\n\n}\n\nIFrameService.ɵfac = function IFrameService_Factory(t) {\n  return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nIFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IFrameService,\n  factory: IFrameService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IFrameService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nclass CheckSessionService {\n  constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.iFrameService = iFrameService;\n    this.eventService = eventService;\n    this.configurationProvider = configurationProvider;\n    this.zone = zone;\n    this.checkSessionReceived = false;\n    this.lastIFrameRefresh = 0;\n    this.outstandingMessages = 0;\n    this.heartBeatInterval = 3000;\n    this.iframeRefreshInterval = 60000;\n    this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n  }\n\n  get checkSessionChanged$() {\n    return this.checkSessionChangedInternal$.asObservable();\n  }\n\n  isCheckSessionConfigured(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession;\n  }\n\n  start(configId) {\n    if (!!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    const {\n      clientId\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    this.pollServerSession(clientId, configId);\n  }\n\n  stop() {\n    if (!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    this.clearScheduledHeartBeat();\n    this.checkSessionReceived = false;\n  }\n\n  serverStateChanged(configId) {\n    const {\n      startCheckSession\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return startCheckSession && this.checkSessionReceived;\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n  }\n\n  init(configId) {\n    if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n      return of(undefined);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n      return of();\n    }\n\n    const existingIframe = this.getOrCreateIframe(configId);\n    const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n    if (checkSessionIframe) {\n      existingIframe.contentWindow.location.replace(checkSessionIframe);\n    } else {\n      this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n    }\n\n    return new Observable(observer => {\n      existingIframe.onload = () => {\n        this.lastIFrameRefresh = Date.now();\n        observer.next();\n        observer.complete();\n      };\n    });\n  }\n\n  pollServerSession(clientId, configId) {\n    this.outstandingMessages = 0;\n\n    const pollServerSessionRecur = () => {\n      this.init(configId).pipe(take(1)).subscribe(() => {\n        var _a;\n\n        const existingIframe = this.getExistingIframe();\n\n        if (existingIframe && clientId) {\n          this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          const sessionState = this.storagePersistenceService.read('session_state', configId);\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n          if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\n            const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\n            this.outstandingMessages++;\n            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n          } else {\n            this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n            this.checkSessionChangedInternal$.next(true);\n          }\n        } else {\n          this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n        } // after sending three messages with no response, fail.\n\n\n        if (this.outstandingMessages > 3) {\n          this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n        }\n\n        this.zone.runOutsideAngular(() => {\n          this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n        });\n      });\n    };\n\n    pollServerSessionRecur();\n  }\n\n  clearScheduledHeartBeat() {\n    clearTimeout(this.scheduledHeartBeatRunning);\n    this.scheduledHeartBeatRunning = null;\n  }\n\n  messageHandler(configId, e) {\n    var _a;\n\n    const existingIFrame = this.getExistingIframe();\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n    const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\n    this.outstandingMessages = 0;\n\n    if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n      if (e.data === 'error') {\n        this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\n      } else if (e.data === 'changed') {\n        this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\n        this.checkSessionReceived = true;\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.checkSessionChangedInternal$.next(true);\n      } else {\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\n      }\n    }\n  }\n\n  bindMessageEventToIframe(configId) {\n    const iframeMessageEvent = this.messageHandler.bind(this, configId);\n    window.addEventListener('message', iframeMessageEvent, false);\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\n      this.bindMessageEventToIframe(configId);\n      return frame;\n    }\n\n    return existingIframe;\n  }\n\n}\n\nCheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n  return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i0.NgZone));\n};\n\nCheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckSessionService,\n  factory: CheckSessionService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckSessionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: IFrameService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass CurrentUrlService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getStateParamFromCurrentUrl() {\n    const currentUrl = this.getCurrentUrl();\n    const parsedUrl = new URL(currentUrl);\n    const urlParams = new URLSearchParams(parsedUrl.search);\n    const stateFromUrl = urlParams.get('state');\n    return stateFromUrl;\n  }\n\n  currentUrlHasStateParam() {\n    return !!this.getStateParamFromCurrentUrl();\n  }\n\n  getCurrentUrl() {\n    return this.doc.defaultView.location.toString();\n  }\n\n}\n\nCurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n  return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CurrentUrlService,\n  factory: CurrentUrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CurrentUrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\nclass SilentRenewService {\n  constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n    this.configurationProvider = configurationProvider;\n    this.iFrameService = iFrameService;\n    this.flowsService = flowsService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsDataService = flowsDataService;\n    this.authStateService = authStateService;\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.intervalService = intervalService;\n    this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n  }\n\n  get refreshSessionWithIFrameCompleted$() {\n    return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n  }\n\n  getOrCreateIframe(configId) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\n    }\n\n    return existingIframe;\n  }\n\n  isSilentRenewConfigured(configId) {\n    const {\n      useRefreshToken,\n      silentRenew\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return !useRefreshToken && silentRenew;\n  }\n\n  codeFlowCallbackSilentRenewIframe(urlParts, configId) {\n    const params = new HttpParams({\n      fromString: urlParts[1]\n    });\n    const error = params.get('error');\n\n    if (error) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: ValidationResult.LoginRequired,\n        isRenewProcess: true\n      });\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      this.flowsDataService.setNonce('', configId);\n      this.intervalService.stopPeriodicTokenCheck();\n      return throwError(error);\n    }\n\n    const code = params.get('code');\n    const state = params.get('state');\n    const sessionState = params.get('session_state');\n    const callbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: true,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError(errorFromFlow => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(errorFromFlow);\n    }));\n  }\n\n  silentRenewEventHandler(e, configId) {\n    this.loggerService.logDebug(configId, 'silentRenewEventHandler');\n\n    if (!e.detail) {\n      return;\n    }\n\n    let callback$ = of(null);\n    const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\n\n    if (isCodeFlow) {\n      const urlParts = e.detail.toString().split('?');\n      callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\n    } else {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\n    }\n\n    callback$.subscribe(callbackContext => {\n      this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n    }, err => {\n      this.loggerService.logError(configId, 'Error: ' + err);\n      this.refreshSessionWithIFrameCompletedInternal$.next(null);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n    });\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n  }\n\n}\n\nSilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n  return new (t || SilentRenewService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n};\n\nSilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SilentRenewService,\n  factory: SilentRenewService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SilentRenewService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: IFrameService\n    }, {\n      type: FlowsService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackService {\n  constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\n    this.flowsService = flowsService;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n    this.configurationProvider = configurationProvider;\n    this.router = router;\n  }\n\n  authenticatedCallbackWithCode(urlToCheck, configId) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(error);\n    }));\n  }\n\n}\n\nCodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n  return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(i2.Router));\n};\n\nCodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackService,\n  factory: CodeFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CallbackService {\n  constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n    this.urlService = urlService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.codeFlowCallbackService = codeFlowCallbackService;\n    this.stsCallbackInternal$ = new Subject();\n  }\n\n  get stsCallback$() {\n    return this.stsCallbackInternal$.asObservable();\n  }\n\n  isCallback(currentUrl) {\n    return this.urlService.isCallbackFromSts(currentUrl);\n  }\n\n  handleCallbackAndFireEvents(currentCallbackUrl, configId) {\n    let callback$;\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\n    } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\n    }\n\n    return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n  }\n\n}\n\nCallbackService.ɵfac = function CallbackService_Factory(t) {\n  return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n};\n\nCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CallbackService,\n  factory: CallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: CodeFlowCallbackService\n    }];\n  }, null);\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\n\nclass AuthWellKnownDataService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\n    return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map(wellKnownEndpoints => ({\n      issuer: wellKnownEndpoints.issuer,\n      jwksUri: wellKnownEndpoints.jwks_uri,\n      authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n      tokenEndpoint: wellKnownEndpoints.token_endpoint,\n      userinfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n      endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n      checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n      revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n      introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n      parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n    })));\n  }\n\n  getWellKnownDocument(wellKnownEndpoint, configId) {\n    let url = wellKnownEndpoint;\n\n    if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n      url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n    }\n\n    return this.http.get(url, configId).pipe(retry(2));\n  }\n\n}\n\nAuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n  return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService));\n};\n\nAuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownDataService,\n  factory: AuthWellKnownDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }];\n  }, null);\n})();\n\nclass AuthWellKnownService {\n  constructor(publicEventsService, dataService, storagePersistenceService) {\n    this.publicEventsService = publicEventsService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\n    const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!!alreadySavedWellKnownEndpoints) {\n      return of(alreadySavedWellKnownEndpoints);\n    }\n\n    return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError(error => {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n      return throwError(error);\n    }));\n  }\n\n  storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\n    this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\n  }\n\n  getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\n    return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\n  }\n\n}\n\nAuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n  return new (t || AuthWellKnownService)(i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nAuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownService,\n  factory: AuthWellKnownService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PublicEventsService\n    }, {\n      type: AuthWellKnownDataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass RefreshSessionIframeService {\n  constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.silentRenewService = silentRenewService;\n    this.renderer = rendererFactory.createRenderer(null, null);\n  }\n\n  refreshSessionWithIframe(configId, customParams) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\n    const url = this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams);\n    return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\n  }\n\n  sendAuthorizeRequestUsingSilentRenew(url, configId) {\n    const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\n    this.initSilentRenewRequest(configId);\n    this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n    return new Observable(observer => {\n      const onLoadHandler = () => {\n        sessionIframe.removeEventListener('load', onLoadHandler);\n        this.loggerService.logDebug(configId, 'removed event listener from IFrame');\n        observer.next(true);\n        observer.complete();\n      };\n\n      sessionIframe.addEventListener('load', onLoadHandler);\n      sessionIframe.contentWindow.location.replace(url);\n    });\n  }\n\n  initSilentRenewRequest(configId) {\n    const instanceId = Math.random();\n    const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n      if (e.detail !== instanceId) {\n        initDestroyHandler();\n        renewDestroyHandler();\n      }\n    });\n    const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, configId));\n    this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n      detail: instanceId\n    }));\n  }\n\n}\n\nRefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n  return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n};\n\nRefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionIframeService,\n  factory: RefreshSessionIframeService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionIframeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\nclass RefreshSessionRefreshTokenService {\n  constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n    this.loggerService = loggerService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsService = flowsService;\n    this.intervalService = intervalService;\n  }\n\n  refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\n    this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\n    return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError(error => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return throwError(error);\n    }));\n  }\n\n}\n\nRefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n  return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n};\n\nRefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionRefreshTokenService,\n  factory: RefreshSessionRefreshTokenService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionRefreshTokenService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\n\nclass RefreshSessionService {\n  constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.silentRenewService = silentRenewService;\n    this.authStateService = authStateService;\n    this.authWellKnownService = authWellKnownService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.userService = userService;\n  }\n\n  userForceRefreshSession(configId, extraCustomParams) {\n    this.persistCustomParams(extraCustomParams, configId);\n    return this.forceRefreshSession(configId, extraCustomParams);\n  }\n\n  forceRefreshSession(configId, extraCustomParams) {\n    const {\n      customParamsRefreshTokenRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n        if (isAuthenticated) {\n          return {\n            idToken: this.authStateService.getIdToken(configId),\n            accessToken: this.authStateService.getAccessToken(configId),\n            userData: this.userService.getUserDataFromStore(configId),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n    const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n    return forkJoin([this.startRefreshSession(configId, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n      var _a, _b;\n\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        return {\n          idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\n          accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\n          userData: this.userService.getUserDataFromStore(configId),\n          isAuthenticated,\n          configId\n        };\n      }\n\n      return null;\n    }));\n  }\n\n  persistCustomParams(extraCustomParams, configId) {\n    const {\n      useRefreshToken\n    } = this.configurationProvider.getOpenIDConfiguration();\n\n    if (extraCustomParams) {\n      if (useRefreshToken) {\n        this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\n      } else {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\n      }\n    }\n  }\n\n  startRefreshSession(configId, extraCustomParams) {\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n    const shouldBeExecuted = !isSilentRenewRunning;\n\n    if (!shouldBeExecuted) {\n      return of(null);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\n      return of(null);\n    }\n\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      this.flowsDataService.setSilentRenewRunning(configId);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n        // Refresh Session using Refresh tokens\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\n      }\n\n      return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\n    }));\n  }\n\n  timeoutRetryStrategy(errorAttempts, configId) {\n    return errorAttempts.pipe(mergeMap((error, index) => {\n      const scalingDuration = 1000;\n      const currentAttempt = index + 1;\n\n      if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n        return throwError(error);\n      }\n\n      this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return timer(currentAttempt * scalingDuration);\n    }));\n  }\n\n}\n\nRefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n  return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n};\n\nRefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionService,\n  factory: RefreshSessionService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: AuthStateService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass PeriodicallyTokenCheckService {\n  constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowHelper = flowHelper;\n    this.configurationProvider = configurationProvider;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.userService = userService;\n    this.authStateService = authStateService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.intervalService = intervalService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n  }\n\n  startTokenValidationPeriodically() {\n    const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\n\n    if (configsWithSilentRenewEnabled.length <= 0) {\n      return;\n    }\n\n    const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n\n    if (!!this.intervalService.runTokenValidationRunning) {\n      return;\n    } // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\n\n\n    const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n      const objectWithConfigIdsAndRefreshEvent = {};\n      configsWithSilentRenewEnabled.forEach(({\n        configId\n      }) => {\n        objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\n      });\n      return forkJoin(objectWithConfigIdsAndRefreshEvent);\n    }));\n    this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe(objectWithConfigIds => {\n      for (const [key, _] of Object.entries(objectWithConfigIds)) {\n        this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\n\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\n          this.flowsDataService.resetSilentRenewRunning(key);\n        }\n      }\n    });\n  }\n\n  getRefreshEvent(configId) {\n    const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\n\n    if (!shouldStartRefreshEvent) {\n      return of(null);\n    }\n\n    const refreshEvent$ = this.createRefreshEventForConfig(configId);\n    this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n    const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n      this.loggerService.logError(configId, 'silent renew failed!', error);\n      this.flowsDataService.resetSilentRenewRunning(configId);\n      return throwError(error);\n    }));\n    return refreshEventWithErrorHandler$;\n  }\n\n  getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n    const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n    return result.tokenRefreshInSeconds;\n  }\n\n  getConfigsWithSilentRenewEnabled() {\n    return this.configurationProvider.getAllConfigurations().filter(x => x.silentRenew);\n  }\n\n  createRefreshEventForConfig(configId) {\n    this.loggerService.logDebug(configId, 'starting silent renew...');\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\n      this.resetAuthDataService.resetAuthorizationData(configId);\n      return of(null);\n    }\n\n    this.flowsDataService.setSilentRenewRunning(configId);\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\n      // Retrieve Dynamically Set Custom Params for refresh body\n      const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\n      const {\n        customParamsRefreshTokenRequest\n      } = this.configurationProvider.getOpenIDConfiguration(configId);\n      const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh); // Refresh Session using Refresh tokens\n\n      return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\n    } // Retrieve Dynamically Set Custom Params\n\n\n    const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\n    return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\n  }\n\n  shouldStartPeriodicallyCheckForConfig(configId) {\n    const idToken = this.authStateService.getIdToken(configId);\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\n    const userDataFromStore = this.userService.getUserDataFromStore(configId);\n    this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n    const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\n\n    if (!shouldBeExecuted) {\n      return false;\n    }\n\n    const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\n    const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\n\n    if (!idTokenStillValid && !accessTokenHasExpired) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nPeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n  return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService));\n};\n\nPeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PeriodicallyTokenCheckService,\n  factory: PeriodicallyTokenCheckService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PeriodicallyTokenCheckService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: UserService\n    }, {\n      type: AuthStateService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: IntervalService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }];\n  }, null);\n})();\n\nclass PopUpService {\n  constructor() {\n    this.STORAGE_IDENTIFIER = 'popupauth';\n    this.resultInternal$ = new Subject();\n  }\n\n  get result$() {\n    return this.resultInternal$.asObservable();\n  }\n\n  isCurrentlyInPopup() {\n    if (this.canAccessSessionStorage()) {\n      const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\n      return !!window.opener && window.opener !== window && !!popup;\n    }\n\n    return false;\n  }\n\n  openPopUp(url, popupOptions) {\n    const optionsToPass = this.getOptions(popupOptions);\n    this.popUp = window.open(url, '_blank', optionsToPass);\n    this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\n\n    const listener = event => {\n      if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\n        return;\n      }\n\n      this.resultInternal$.next({\n        userClosed: false,\n        receivedUrl: event.data\n      });\n      this.cleanUp(listener);\n    };\n\n    window.addEventListener('message', listener, false);\n    this.handle = window.setInterval(() => {\n      if (this.popUp.closed) {\n        this.resultInternal$.next({\n          userClosed: true\n        });\n        this.cleanUp(listener);\n      }\n    }, 200);\n  }\n\n  sendMessageToMainWindow(url) {\n    if (window.opener) {\n      this.sendMessage(url, window.location.href);\n    }\n  }\n\n  cleanUp(listener) {\n    var _a;\n\n    window.removeEventListener('message', listener, false);\n    window.clearInterval(this.handle);\n\n    if (this.popUp) {\n      (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\n      this.popUp.close();\n      this.popUp = null;\n    }\n  }\n\n  sendMessage(url, href) {\n    window.opener.postMessage(url, href);\n  }\n\n  getOptions(popupOptions) {\n    const popupDefaultOptions = {\n      width: 500,\n      height: 500,\n      left: 50,\n      top: 50\n    };\n    const options = Object.assign(Object.assign({}, popupDefaultOptions), popupOptions || {});\n    return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n  }\n\n  canAccessSessionStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nPopUpService.ɵfac = function PopUpService_Factory(t) {\n  return new (t || PopUpService)();\n};\n\nPopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpService,\n  factory: PopUpService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass CheckAuthService {\n  constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\n    this.checkSessionService = checkSessionService;\n    this.currentUrlService = currentUrlService;\n    this.silentRenewService = silentRenewService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.callbackService = callbackService;\n    this.refreshSessionService = refreshSessionService;\n    this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n    this.popupService = popupService;\n    this.autoLoginService = autoLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  checkAuth(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(`could not find matching config for state ${stateParamFromUrl}`);\n      }\n\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n      return this.checkAuthWithConfig(config, url);\n    }\n\n    const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\n    return this.checkAuthWithConfig(onlyExistingConfig, url);\n  }\n\n  checkAuthMultiple(passedConfigId, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(stateParamFromUrl);\n\n      if (!config) {\n        return throwError(`could not find matching config for state ${stateParamFromUrl}`);\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    if (!!passedConfigId) {\n      const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\n\n      if (!config) {\n        return throwError(`could not find matching config for id ${passedConfigId}`);\n      }\n\n      return this.composeMultipleLoginResults(config, url);\n    }\n\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    const allChecks$ = allConfigs.map(x => this.checkAuthWithConfig(x, url));\n    return forkJoin(allChecks$);\n  }\n\n  checkAuthIncludingServer(configId) {\n    const config = this.configurationProvider.getOpenIDConfiguration(configId);\n    return this.checkAuthWithConfig(config).pipe(switchMap(loginResponse => {\n      const {\n        isAuthenticated\n      } = loginResponse;\n\n      if (isAuthenticated) {\n        return of(loginResponse);\n      }\n\n      return this.refreshSessionService.forceRefreshSession(configId).pipe(tap(loginResponseAfterRefreshSession => {\n        if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\n          this.startCheckSessionAndValidation(configId);\n        }\n      }));\n    }));\n  }\n\n  checkAuthWithConfig(config, url) {\n    const {\n      configId,\n      authority\n    } = config;\n\n    if (!this.configurationProvider.hasAsLeastOneConfig()) {\n      const errorMessage = 'Please provide at least one configuration before setting up the module';\n      this.loggerService.logError(configId, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }\n\n    const currentUrl = url || this.currentUrlService.getCurrentUrl();\n    this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\n\n    if (this.popupService.isCurrentlyInPopup()) {\n      this.popupService.sendMessageToMainWindow(currentUrl);\n      return of(null);\n    }\n\n    const isCallback = this.callbackService.isCallback(currentUrl);\n    this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\n    const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\n    return callback$.pipe(map(() => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n      if (isAuthenticated) {\n        this.startCheckSessionAndValidation(configId);\n\n        if (!isCallback) {\n          this.authStateService.setAuthenticatedAndFireEvent();\n          this.userService.publishUserDataIfExists(configId);\n        }\n      }\n\n      this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n      return {\n        isAuthenticated,\n        userData: this.userService.getUserDataFromStore(configId),\n        accessToken: this.authStateService.getAccessToken(configId),\n        idToken: this.authStateService.getIdToken(configId),\n        configId\n      };\n    }), tap(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n    }), catchError(errorMessage => {\n      this.loggerService.logError(configId, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }));\n  }\n\n  startCheckSessionAndValidation(configId) {\n    if (this.checkSessionService.isCheckSessionConfigured(configId)) {\n      this.checkSessionService.start(configId);\n    }\n\n    this.periodicallyTokenCheckService.startTokenValidationPeriodically();\n\n    if (this.silentRenewService.isSilentRenewConfigured(configId)) {\n      this.silentRenewService.getOrCreateIframe(configId);\n    }\n  }\n\n  getConfigurationWithUrlState(stateFromUrl) {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n\n    for (const config of allConfigs) {\n      const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\n\n      if (storedState === stateFromUrl) {\n        return config;\n      }\n    }\n\n    return null;\n  }\n\n  composeMultipleLoginResults(activeConfig, url) {\n    const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter(x => x.configId !== activeConfig.configId);\n    const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\n    const allOtherConfigResults = allOtherConfigs.map(config => {\n      const {\n        redirectUrl\n      } = config;\n      return this.checkAuthWithConfig(config, redirectUrl);\n    });\n    return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n  }\n\n}\n\nCheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n  return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nCheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckAuthService,\n  factory: CheckAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CurrentUrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: CallbackService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: PeriodicallyTokenCheckService\n    }, {\n      type: PopUpService\n    }, {\n      type: AutoLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  storage: typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined' ? sessionStorage : null,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  eagerLoadAuthWellKnownEndpoints: true,\n  disableRefreshIdTokenAuthTimeValidation: false,\n  enableIdTokenExpiredValidationInRenew: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectURL is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  validateConfigs(passedConfigs) {\n    return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\n  }\n\n  validateConfig(passedConfig) {\n    return this.validateConfigInternal(passedConfig, allRules);\n  }\n\n  validateConfigsInternal(passedConfigs, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n    let overallErrorCount = 0;\n    passedConfigs.forEach(passedConfig => {\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\n      overallErrorCount += errorCount;\n    });\n    return overallErrorCount === 0;\n  }\n\n  validateConfigInternal(passedConfig, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n    const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\n    return errorCount === 0;\n  }\n\n  processValidationResultsAndGetErrorCount(allValidationResults, configId) {\n    const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n    const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n    const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n    allErrorMessages.forEach(message => this.loggerService.logError(configId, message));\n    allWarnings.forEach(message => this.loggerService.logWarning(configId, message));\n    return allErrorMessages.length;\n  }\n\n  getAllMessagesOfType(type, results) {\n    const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n    return allMessages.reduce((acc, val) => acc.concat(val), []);\n  }\n\n}\n\nConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n  return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n};\n\nConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigValidationService,\n  factory: ConfigValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass PlatformProvider {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  get isBrowser() {\n    return isPlatformBrowser(this.platformId);\n  }\n\n}\n\nPlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n  return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nPlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PlatformProvider,\n  factory: PlatformProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformProvider, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass OidcConfigService {\n  constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider) {\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.configValidationService = configValidationService;\n    this.platformProvider = platformProvider;\n  }\n\n  withConfigs(passedConfigs) {\n    if (!this.configValidationService.validateConfigs(passedConfigs)) {\n      return Promise.resolve(null);\n    }\n\n    this.createUniqueIds(passedConfigs);\n    const allHandleConfigPromises = passedConfigs.map(x => this.handleConfig(x));\n    return Promise.all(allHandleConfigPromises);\n  }\n\n  createUniqueIds(passedConfigs) {\n    passedConfigs.forEach((config, index) => {\n      if (!config.configId) {\n        config.configId = `${index}-${config.clientId}`;\n      }\n    });\n  }\n\n  handleConfig(passedConfig) {\n    return new Promise((resolve, reject) => {\n      if (!this.configValidationService.validateConfig(passedConfig)) {\n        this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\n        resolve(null);\n        return;\n      }\n\n      if (!passedConfig.authWellknownEndpointUrl) {\n        passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n      }\n\n      const usedConfig = this.prepareConfig(passedConfig);\n      this.configurationProvider.setConfig(usedConfig);\n      const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\n\n      if (!!alreadyExistingAuthWellKnownEndpoints) {\n        usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n        return;\n      }\n\n      const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\n\n      if (!!passedAuthWellKnownEndpoints) {\n        this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\n        usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n        return;\n      }\n\n      if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\n        this.authWellKnownService.getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId).pipe(catchError(error => {\n          this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\n          return throwError(error);\n        }), tap(wellknownEndPoints => {\n          usedConfig.authWellknownEndpoints = wellknownEndPoints;\n          this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        })).subscribe(() => resolve(usedConfig), () => reject());\n      } else {\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\n        resolve(usedConfig);\n      }\n    });\n  }\n\n  prepareConfig(configuration) {\n    const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\n    this.setSpecialCases(openIdConfigurationInternal);\n    return openIdConfigurationInternal;\n  }\n\n  setSpecialCases(currentConfig) {\n    if (!this.platformProvider.isBrowser) {\n      currentConfig.startCheckSession = false;\n      currentConfig.silentRenew = false;\n      currentConfig.useRefreshToken = false;\n      currentConfig.usePushedAuthorisationRequests = false;\n    }\n  }\n\n}\n\nOidcConfigService.ɵfac = function OidcConfigService_Factory(t) {\n  return new (t || OidcConfigService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider));\n};\n\nOidcConfigService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcConfigService,\n  factory: OidcConfigService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcConfigService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ConfigValidationService\n    }, {\n      type: PlatformProvider\n    }];\n  }, null);\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      const allInstantStaticPromises = this.passedConfigs.map(x => new Promise((resolve, _) => resolve(x)));\n      return allInstantStaticPromises;\n    }\n\n    const singleStaticPromise = new Promise((resolve, _) => resolve(this.passedConfigs));\n    return [singleStaticPromise];\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\n  }\n\n}\n\nclass ClosestMatchingRouteService {\n  constructor(configProvider) {\n    this.configProvider = configProvider;\n  }\n\n  getConfigIdForClosestMatchingRoute(route) {\n    const allConfiguredRoutes = this.getAllConfiguredRoutes();\n\n    for (const routesWithConfig of allConfiguredRoutes) {\n      const allRoutesForConfig = routesWithConfig.routes;\n\n      for (const configuredRoute of allRoutesForConfig) {\n        if (route.startsWith(configuredRoute)) {\n          return {\n            matchingRoute: configuredRoute,\n            matchingConfigId: routesWithConfig.configId\n          };\n        }\n      }\n    }\n\n    return {\n      matchingRoute: null,\n      matchingConfigId: null\n    };\n  }\n\n  getAllConfiguredRoutes() {\n    const allConfigurations = this.configProvider.getAllConfigurations();\n    return allConfigurations.map(x => ({\n      routes: x.secureRoutes,\n      configId: x.configId\n    }));\n  }\n\n}\n\nClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n  return new (t || ClosestMatchingRouteService)(i0.ɵɵinject(ConfigurationProvider));\n};\n\nClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ClosestMatchingRouteService,\n  factory: ClosestMatchingRouteService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ClosestMatchingRouteService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass ResponseTypeValidationService {\n  constructor(loggerService, flowHelper) {\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n  }\n\n  hasConfigValidResponseType(configId) {\n    if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\n      return true;\n    }\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\n      return true;\n    }\n\n    this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n    return false;\n  }\n\n}\n\nResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n  return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n};\n\nResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResponseTypeValidationService,\n  factory: ResponseTypeValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResponseTypeValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass RedirectService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  redirectTo(url) {\n    this.doc.location.href = url;\n  }\n\n}\n\nRedirectService.ɵfac = function RedirectService_Factory(t) {\n  return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n};\n\nRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RedirectService,\n  factory: RedirectService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RedirectService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParService {\n  constructor(loggerService, urlService, dataService, storagePersistenceService) {\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  postParRequest(configId, customParams) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\n\n    if (!authWellknownEndpoints) {\n      return throwError('Could not read PAR endpoint because authWellKnownEndPoints are not given');\n    }\n\n    const parEndpoint = authWellknownEndpoints.parEndpoint;\n\n    if (!parEndpoint) {\n      return throwError('Could not read PAR endpoint from authWellKnownEndpoints');\n    }\n\n    const data = this.urlService.createBodyForParCodeFlowRequest(configId, customParams);\n    return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      return {\n        expiresIn: response.expires_in,\n        requestUri: response.request_uri\n      };\n    }), catchError(error => {\n      const errorMessage = `There was an error on ParService postParRequest`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n}\n\nParService.ɵfac = function ParService_Factory(t) {\n  return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParService,\n  factory: ParService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass ParLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n    this.parService = parService;\n  }\n\n  loginPar(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams))).subscribe(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        this.loggerService.logError(configId, `Could not create url with param ${response.requestUri}: '${url}'`);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n  loginWithPopUpPar(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    const {\n      customParams\n    } = authOptions || {};\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap(response => {\n      this.loggerService.logDebug(configId, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\n      this.loggerService.logDebug(configId, 'par request url: ', url);\n\n      if (!url) {\n        const errorMessage = `Could not create url with param ${response.requestUri}: 'url'`;\n        this.loggerService.logError(configId, errorMessage);\n        return throwError(errorMessage);\n      }\n\n      this.popupService.openPopUp(url, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nParLoginService.ɵfac = function ParLoginService_Factory(t) {\n  return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n};\n\nParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParLoginService,\n  factory: ParLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: ParService\n    }];\n  }, null);\n})();\n\nclass PopUpLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n  }\n\n  loginWithPopUpStandard(configId, authOptions, popupOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(configId, errorMessage);\n      return throwError(errorMessage);\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\n      const {\n        customParams\n      } = authOptions || {};\n      const authUrl = this.urlService.getAuthorizeUrl(configId, customParams);\n      this.popupService.openPopUp(authUrl, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configId, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nPopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n  return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n};\n\nPopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpLoginService,\n  factory: PopUpLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }];\n  }, null);\n})();\n\nclass StandardLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n    this.authWellKnownService = authWellKnownService;\n  }\n\n  loginStandard(configId, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\n      this.loggerService.logError(configId, 'Invalid response type!');\n      return;\n    }\n\n    const {\n      authWellknownEndpointUrl\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (!authWellknownEndpointUrl) {\n      this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\n      return;\n    }\n\n    this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\n    this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\n      const {\n        urlHandler,\n        customParams\n      } = authOptions || {};\n      const url = this.urlService.getAuthorizeUrl(configId, customParams);\n\n      if (!url) {\n        this.loggerService.logError(configId, 'Could not create url', url);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n}\n\nStandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n  return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthWellKnownService));\n};\n\nStandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StandardLoginService,\n  factory: StandardLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StandardLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthWellKnownService\n    }];\n  }, null);\n})();\n\nclass LoginService {\n  constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\n    this.configurationProvider = configurationProvider;\n    this.parLoginService = parLoginService;\n    this.popUpLoginService = popUpLoginService;\n    this.standardLoginService = standardLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  login(configId, authOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginPar(configId, authOptions);\n    } else {\n      return this.standardLoginService.loginStandard(configId, authOptions);\n    }\n  }\n\n  loginWithPopUp(configId, authOptions, popupOptions) {\n    if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\n    }\n\n    const {\n      usePushedAuthorisationRequests\n    } = this.configurationProvider.getOpenIDConfiguration(configId);\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\n    } else {\n      return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\n    }\n  }\n\n}\n\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: ParLoginService\n    }, {\n      type: PopUpLoginService\n    }, {\n      type: StandardLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass LogoffRevocationService {\n  constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.checkSessionService = checkSessionService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.redirectService = redirectService;\n    this.configurationProvider = configurationProvider;\n  } // Logs out on the server and the local client.\n  // If the server state has changed, check session, then only a local logout.\n\n\n  logoff(configId, authOptions) {\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.loggerService.logDebug(configId, 'logoff, remove auth ');\n    const endSessionUrl = this.getEndSessionUrl(configId, customParams);\n    this.resetAuthDataService.resetAuthorizationData(configId);\n\n    if (!endSessionUrl) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\n      return;\n    }\n\n    if (this.checkSessionService.serverStateChanged(configId)) {\n      this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\n    } else if (urlHandler) {\n      urlHandler(endSessionUrl);\n    } else {\n      this.redirectService.redirectTo(endSessionUrl);\n    }\n  }\n\n  logoffLocal(configId) {\n    this.resetAuthDataService.resetAuthorizationData(configId);\n    this.checkSessionService.stop();\n  }\n\n  logoffLocalMultiple() {\n    const allConfigs = this.configurationProvider.getAllConfigurations();\n    allConfigs.forEach(({\n      configId\n    }) => this.logoffLocal(configId));\n  } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n  // only the access token is revoked. Then the logout run.\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    const {\n      revocationEndpoint\n    } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\n\n    if (!revocationEndpoint) {\n      this.loggerService.logDebug(configId, 'revocation endpoint not supported');\n      this.logoff(configId, authOptions);\n    }\n\n    if (this.storagePersistenceService.getRefreshToken(configId)) {\n      return this.revokeRefreshToken(configId).pipe(switchMap(result => this.revokeAccessToken(configId, result)), catchError(error => {\n        const errorMessage = `revoke token failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(errorMessage);\n      }), tap(() => this.logoff(configId, authOptions)));\n    } else {\n      return this.revokeAccessToken(configId).pipe(catchError(error => {\n        const errorMessage = `revoke accessToken failed`;\n        this.loggerService.logError(configId, errorMessage, error);\n        return throwError(errorMessage);\n      }), tap(() => this.logoff(configId, authOptions)));\n    }\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an access token on the STS. If no token is provided, then the token from\n  // the storage is revoked. You can pass any token to revoke. This makes it possible to\n  // manage your own tokens. The is a public API.\n\n\n  revokeAccessToken(configId, accessToken) {\n    const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n  // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n  // This makes it possible to manage your own tokens.\n\n\n  revokeRefreshToken(configId, refreshToken) {\n    const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\n    const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\n    return this.sendRevokeRequest(configId, body);\n  }\n\n  getEndSessionUrl(configId, customParams) {\n    const idToken = this.storagePersistenceService.getIdToken(configId);\n    const {\n      customParamsEndSessionRequest\n    } = this.configurationProvider.getOpenIDConfiguration();\n    const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\n    return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\n  }\n\n  sendRevokeRequest(configId, body) {\n    const url = this.urlService.getRevocationEndpointUrl(configId);\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap(response => {\n      this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\n      return of(response);\n    }), catchError(error => {\n      const errorMessage = `Revocation request failed`;\n      this.loggerService.logError(configId, errorMessage, error);\n      return throwError(errorMessage);\n    }));\n  }\n\n}\n\nLogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n  return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nLogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LogoffRevocationService,\n  factory: LogoffRevocationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LogoffRevocationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: CheckSessionService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: RedirectService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass OidcSecurityService {\n  constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService) {\n    this.checkSessionService = checkSessionService;\n    this.checkAuthService = checkAuthService;\n    this.userService = userService;\n    this.tokenHelperService = tokenHelperService;\n    this.configurationProvider = configurationProvider;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.callbackService = callbackService;\n    this.logoffRevocationService = logoffRevocationService;\n    this.loginService = loginService;\n    this.refreshSessionService = refreshSessionService;\n  }\n  /**\r\n   * Provides information about the user after they have logged in.\r\n   *\r\n   * @returns Returns an object containing either the user data directly (single config) or\r\n   * the user data per config in case you are running with multiple configs\r\n   */\n\n\n  get userData$() {\n    return this.userService.userData$;\n  }\n  /**\r\n   * Emits each time an authorization event occurs.\r\n   *\r\n   * @returns Returns an object containing if you are authenticated or not.\r\n   * Single Config: true if config is authenticated, false if not.\r\n   * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n   *\r\n   * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n   */\n\n\n  get isAuthenticated$() {\n    return this.authStateService.authenticated$;\n  }\n  /**\r\n   * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n   * true.\r\n   */\n\n\n  get checkSessionChanged$() {\n    return this.checkSessionService.checkSessionChanged$;\n  }\n  /**\r\n   * Emits on a secure token server callback. The observable will never contain a value.\r\n   */\n\n\n  get stsCallback$() {\n    return this.callbackService.stsCallback$;\n  }\n  /**\r\n   * Returns the currently active OpenID configurations.\r\n   *\r\n   * @returns an array of OpenIdConfigurations.\r\n   */\n\n\n  getConfigurations() {\n    return this.configurationProvider.getAllConfigurations();\n  }\n  /**\r\n   * Returns a single active OpenIdConfiguration.\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n   */\n\n\n  getConfiguration(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.configurationProvider.getOpenIDConfiguration(configId);\n  }\n  /**\r\n   * Returns the userData for a configuration\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being used\r\n   */\n\n\n  getUserData(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\n    return this.userService.getUserDataFromStore(configId);\n  }\n  /**\r\n   * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened\r\n   *\r\n   * @param url The url to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An object `LoginResponse` containing all information about the login\r\n   */\n\n\n  checkAuth(url, configId) {\n    return this.checkAuthService.checkAuth(configId, url);\n  }\n  /**\r\n   * Starts the complete setup flow for multiple configurations.\r\n   * Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened in an array for each config which was provided\r\n   *\r\n   * @param url The url to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n   * configured ones will be used to check.\r\n   *\r\n   * @returns An array of `LoginResponse` objects containing all information about the logins\r\n   */\n\n\n  checkAuthMultiple(url, configId) {\n    return this.checkAuthService.checkAuthMultiple(configId, url);\n  }\n  /**\r\n   * Provides information about the current authenticated state\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A boolean whether the config is authenticated or not.\r\n   */\n\n\n  isAuthenticated(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.isAuthenticated(configId);\n  }\n  /**\r\n   * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n   */\n\n\n  checkAuthIncludingServer(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.checkAuthService.checkAuthIncludingServer(configId);\n  }\n  /**\r\n   * Returns the access token for the login scenario.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the access token.\r\n   */\n\n\n  getAccessToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAccessToken(configId);\n  }\n  /**\r\n   * Returns the ID token for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the id token.\r\n   */\n\n\n  getIdToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getIdToken(configId);\n  }\n  /**\r\n   * Returns the refresh token, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the refresh token.\r\n   */\n\n\n  getRefreshToken(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getRefreshToken(configId);\n  }\n  /**\r\n   * Returns the authentication result, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A object with the authentication result\r\n   */\n\n\n  getAuthenticationResult(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.authStateService.getAuthenticationResult(configId);\n  }\n  /**\r\n   * Returns the payload from the ID token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the id token.\r\n   */\n\n\n  getPayloadFromIdToken(encode = false, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    const token = this.authStateService.getIdToken(configId);\n    return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\n  }\n  /**\r\n   * Sets a custom state for the authorize request.\r\n   *\r\n   * @param state The state to set.\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   */\n\n\n  setState(state, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.flowsDataService.setAuthStateControl(state, configId);\n  }\n  /**\r\n   * Gets the state value used for the authorize request.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The state value used for the authorize request.\r\n   */\n\n\n  getState(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.flowsDataService.getAuthStateControl(configId);\n  }\n  /**\r\n   * Redirects the user to the secure token server to begin the authentication process.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the the authentication request.\r\n   */\n\n\n  authorize(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    this.loginService.login(configId, authOptions);\n  }\n  /**\r\n   * Opens the secure token server in a new window to begin the authentication process.\r\n   *\r\n   * @param authOptions The custom options for the authentication request.\r\n   * @param popupOptions The configuration for the popup window.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  authorizeWithPopUp(authOptions, popupOptions, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\n  }\n  /**\r\n   * Manually refreshes the session.\r\n   *\r\n   * @param customParams Custom parameters to pass to the refresh request.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  forceRefreshSession(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.refreshSessionService.userForceRefreshSession(configId, customParams);\n  }\n  /**\r\n   * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n   * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n   * only the access token is revoked. Then the logout run.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the request.\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\n  }\n  /**\r\n   * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n   * then only a local logout is performed.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions with custom parameters and/or an custom url handler\r\n   */\n\n\n  logoff(configId, authOptions) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoff(configId, authOptions);\n  }\n  /**\r\n   * Logs the user out of the application without logging them out of the server.\r\n   * Use this method if you have _one_ config enabled.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   */\n\n\n  logoffLocal(configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.logoffLocal(configId);\n  }\n  /**\r\n   * Logs the user out of the application for all configs without logging them out of the server.\r\n   * Use this method if you have _multiple_ configs enabled.\r\n   */\n\n\n  logoffLocalMultiple() {\n    return this.logoffRevocationService.logoffLocalMultiple();\n  }\n  /**\r\n   * Revokes an access token on the secure token server. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param accessToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeAccessToken(accessToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\n  }\n  /**\r\n   * Revokes a refresh token on the secure token server. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param refreshToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeRefreshToken(refreshToken, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\n  }\n  /**\r\n   * Creates the end session URL which can be used to implement an alternate server logout.\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the end session url or null\r\n   */\n\n\n  getEndSessionUrl(customParams, configId) {\n    configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\n    return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\n  }\n\n}\n\nOidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n  return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService));\n};\n\nOidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcSecurityService,\n  factory: OidcSecurityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcSecurityService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: UserService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: CallbackService\n    }, {\n      type: LogoffRevocationService\n    }, {\n      type: LoginService\n    }, {\n      type: RefreshSessionService\n    }];\n  }, null);\n})();\n\nclass BrowserStorageService {\n  constructor(configProvider, loggerService) {\n    this.configProvider = configProvider;\n    this.loggerService = loggerService;\n  }\n\n  read(key, configId) {\n    var _a;\n\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\n      return false;\n    }\n\n    const item = (_a = this.getStorage(configId)) === null || _a === void 0 ? void 0 : _a.getItem(key);\n\n    if (!item) {\n      return null;\n    }\n\n    return JSON.parse(item);\n  }\n\n  write(key, value, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to write '${key}/${value}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${key}/${value}' but Storage was falsy`);\n      return false;\n    }\n\n    value = value || null;\n    storage.setItem(`${key}`, JSON.stringify(value));\n    return true;\n  }\n\n  remove(key, configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\n      return false;\n    }\n\n    storage.removeItem(`${key}`);\n    return true;\n  } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n  clear(configId) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    const storage = this.getStorage(configId);\n\n    if (!storage) {\n      this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    }\n\n    storage.clear();\n    return true;\n  }\n\n  getStorage(configId) {\n    const {\n      storage\n    } = this.configProvider.getOpenIDConfiguration(configId) || {};\n    return storage;\n  }\n\n  hasStorage() {\n    return typeof Storage !== 'undefined';\n  }\n\n}\n\nBrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n  return new (t || BrowserStorageService)(i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService));\n};\n\nBrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserStorageService,\n  factory: BrowserStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserStorageService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n} // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction configurationProviderFactory(oidcConfigService, loader) {\n  const allLoadPromises = Promise.all(loader.loadConfigs());\n\n  const fn = () => allLoadPromises.then(configs => oidcConfigService.withConfigs(configs));\n\n  return fn;\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\n\nclass AuthModule {\n  static forRoot(passedConfig) {\n    return {\n      ngModule: AuthModule,\n      providers: [// Make the PASSED_CONFIG available through injection\n      {\n        provide: PASSED_CONFIG,\n        useValue: passedConfig\n      }, // Create the loader: Either the one getting passed or a static one\n      (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || {\n        provide: StsConfigLoader,\n        useFactory: createStaticLoader,\n        deps: [PASSED_CONFIG]\n      }, // Load the config when the app starts\n      {\n        provide: APP_INITIALIZER,\n        multi: true,\n        deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\n        useFactory: configurationProviderFactory\n      }, {\n        provide: AbstractSecurityStorage,\n        useClass: (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.storage) || BrowserStorageService\n      }, OidcConfigService, PublicEventsService, FlowHelper, ConfigurationProvider, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, LoggerService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JsrsAsignReducedService, CurrentUrlService, ClosestMatchingRouteService]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule, HttpClientModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, HttpClientModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nclass AutoLoginAllRoutesGuard {\n  constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.checkAuthService = checkAuthService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    return this.checkAuthService.checkAuth().pipe(take(1), map(({\n      isAuthenticated\n    }) => {\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n      }\n\n      if (!isAuthenticated) {\n        this.autoLoginService.saveRedirectRoute(configId, url);\n        this.loginService.login(configId);\n      }\n\n      return isAuthenticated;\n    }));\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n  return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginAllRoutesGuard,\n  factory: AutoLoginAllRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginAllRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AutoLoginPartialRoutesGuard {\n  constructor(autoLoginService, authStateService, loginService, configurationProvider) {\n    this.autoLoginService = autoLoginService;\n    this.authStateService = authStateService;\n    this.loginService = loginService;\n    this.configurationProvider = configurationProvider;\n  }\n\n  canLoad(route, segments) {\n    const routeToRedirect = segments.join('/');\n    return this.checkAuth(routeToRedirect);\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    const configId = this.getId();\n    const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\n\n    if (isAuthenticated) {\n      this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\n    }\n\n    if (!isAuthenticated) {\n      this.autoLoginService.saveRedirectRoute(configId, url);\n      this.loginService.login(configId);\n    }\n\n    return isAuthenticated;\n  }\n\n  getId() {\n    return this.configurationProvider.getOpenIDConfiguration().configId;\n  }\n\n}\n\nAutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n  return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationProvider));\n};\n\nAutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginPartialRoutesGuard,\n  factory: AutoLoginPartialRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginPartialRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationProvider\n    }];\n  }, null);\n})();\n\nclass AuthInterceptor {\n  constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\n    this.authStateService = authStateService;\n    this.configurationProvider = configurationProvider;\n    this.loggerService = loggerService;\n    this.closestMatchingRouteService = closestMatchingRouteService;\n  }\n\n  intercept(req, next) {\n    if (!this.configurationProvider.hasAsLeastOneConfig()) {\n      return next.handle(req);\n    }\n\n    const allConfigurations = this.configurationProvider.getAllConfigurations();\n    const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n    const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\n\n    if (allRoutesConfiguredFlat.length === 0) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `No routes to check configured`);\n      return next.handle(req);\n    }\n\n    const {\n      matchingConfigId,\n      matchingRoute\n    } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\n\n    if (!matchingConfigId) {\n      const {\n        configId\n      } = allConfigurations[0];\n      this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\n    const token = this.authStateService.getAccessToken(matchingConfigId);\n\n    if (!token) {\n      this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n    req = req.clone({\n      headers: req.headers.set('Authorization', 'Bearer ' + token)\n    });\n    return next.handle(req);\n  }\n\n}\n\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationProvider), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n};\n\nAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: ConfigurationProvider\n    }, {\n      type: LoggerService\n    }, {\n      type: ClosestMatchingRouteService\n    }];\n  }, null);\n})(); // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };","map":{"version":3,"sources":["C:/repos/git/damienbod/AspNetCoreID4External/src/AngularCliClient/node_modules/angular-auth-oidc-client/fesm2015/angular-auth-oidc-client.js"],"names":["DOCUMENT","isPlatformBrowser","CommonModule","i1","HttpHeaders","HttpParams","HttpErrorResponse","HttpResponse","HttpClientModule","i0","Injectable","Inject","PLATFORM_ID","InjectionToken","APP_INITIALIZER","NgModule","ReplaySubject","BehaviorSubject","throwError","of","timer","Observable","Subject","forkJoin","TimeoutError","distinctUntilChanged","switchMap","retryWhen","catchError","mergeMap","map","retry","tap","concatMap","take","timeout","KJUR","hextob64u","KEYUTIL","i2","HttpBaseService","constructor","http","get","url","params","post","body","ɵfac","HttpClient","ɵprov","type","ConfigurationProvider","configsInternal","hasAsLeastOneConfig","Object","keys","length","hasManyConfigs","setConfig","readyConfig","configId","getOpenIDConfiguration","value","entries","getAllConfigurations","values","NGSW_CUSTOM_PARAM","DataService","httpClient","configurationProvider","token","headers","prepareHeaders","prepareParams","headersParams","set","decodeURIComponent","ngswBypass","EventTypes","AbstractSecurityStorage","StoragePersistenceService","oidcSecurityStorage","read","key","storedConfig","write","remove","clear","resetStorageFlowData","resetAuthStateInStorage","getAccessToken","getIdToken","_a","id_token","getRefreshToken","refresh_token","getAuthenticationResult","LogLevel","LoggerService","logError","message","args","loggingIsTurnedOff","console","error","logWarning","logLevelIsSet","currentLogLevelIsEqualOrSmallerThan","Warn","warn","logDebug","Debug","log","logLevelToCompare","logLevel","undefined","None","PublicEventsService","notify","fireEvent","next","registerForEvents","asObservable","PARTS_OF_TOKEN","TokenHelperService","loggerService","getTokenExpirationDate","dataIdToken","hasOwnProperty","Date","toUTCString","date","setUTCSeconds","exp","getHeaderFromToken","encoded","tokenIsValid","getPartOfToken","getPayloadFromToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","JSON","parse","str","output","replace","Error","decoded","window","atob","Buffer","from","toString","split","c","charCodeAt","slice","join","err","includes","parts","JsrsAsignReducedService","generateCodeChallenge","codeVerifier","hash","crypto","Util","hashString","testData","generateAtHash","accessToken","sha","first128bits","substr","TokenValidationService","tokenHelperService","jsrsAsignReducedService","keyAlgorithms","hasIdTokenExpired","offsetSeconds","validateIdTokenExpNotExpired","decodedIdToken","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","tokenNotExpired","millisToMinutesAndSeconds","toLocaleTimeString","validateAccessTokenNotExpired","accessTokenExpiresAt","accessTokenExpirationValue","validateRequiredIdToken","validated","validateIdTokenIatMaxOffset","maxOffsetAllowedInSeconds","disableIatOffsetValidation","dateTimeIatIdToken","iat","nowInUtc","diff","maxOffsetAllowedInMilliseconds","validateIdTokenNonce","localNonce","ignoreNonceAfterRefresh","isFromRefreshToken","nonce","refreshTokenNoncePlaceholder","validateIdTokenIss","authWellKnownEndpointsIssuer","iss","validateIdTokenAud","aud","Array","isArray","validateIdTokenAzpExistsIfMoreThanOneAud","azp","validateIdTokenAzpValid","clientId","validateStateFromHashCallback","state","localState","validateSignatureIdToken","idToken","jwtkeys","headerData","kid","alg","jwtKtyToUse","charAt","isValid","keyToValidate","kty","amountOfMatchingKeys","use","jws","JWS","verify","getKey","publicKey","validateIdTokenAtHash","atHash","idTokenAlg","testValue","millis","minutes","Math","floor","seconds","toFixed","DEFAULT_AUTHRESULT","isAuthenticated","allConfigsAuthenticated","AuthStateService","storagePersistenceService","publicEventsService","tokenValidationService","authenticatedInternal$","authenticated$","pipe","setAuthenticatedAndFireEvent","composeAuthenticatedResult","setUnauthenticatedAndFireEvent","configIdToReset","composeUnAuthenticatedResult","updateAndPublishAuthState","authenticationResult","NewAuthenticationResult","setAuthorizationData","authResult","persistAccessTokenExpirationTime","decodeURIComponentSafely","areAuthStorageTokensValid","hasIdTokenExpiredAndRenewCheckIsEnabled","hasAccessTokenExpiredIfExpiryExists","renewTimeBeforeTokenExpiresInSeconds","enableIdTokenExpiredValidationInRenew","tokenToCheck","idTokenExpired","IdTokenExpired","accessTokenExpiresIn","accessTokenHasNotExpired","hasExpired","TokenExpired","expires_in","accessTokenExpiryTime","checkAllConfigsIfTheyAreAuthenticated","configs","every","x","STORAGE_KEY","AutoLoginService","storageService","router","checkSavedRedirectRouteAndNavigate","savedRouteForRedirect","getStoredRedirectRoute","deleteStoredRedirectRoute","navigateByUrl","saveRedirectRoute","Router","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","RandomService","doc","createRandom","requiredLength","arr","Uint8Array","getCrypto","getRandomValues","toHex","randomString","dec","characters","Uint32Array","i","defaultView","msCrypto","decorators","FlowsDataService","randomService","createNonce","setNonce","getAuthStateControl","setAuthStateControl","authStateControl","getExistingOrCreateAuthStateControl","setSessionState","sessionState","getCodeVerifier","createCodeVerifier","isSilentRenewRunning","storageObject","getSilentRenewRunningStorageEntry","silentRenewTimeoutInSeconds","timeOutInMilliseconds","dateOfLaunchedProcessUtc","currentDateUtc","toISOString","elapsedTimeInMilliseconds","abs","isProbablyStuck","resetSilentRenewRunning","setSilentRenewRunning","stringify","storageEntry","FlowHelper","isCurrentFlowCodeFlow","currentFlowIs","isCurrentFlowAnyImplicitFlow","isCurrentFlowImplicitFlowWithAccessToken","isCurrentFlowImplicitFlowWithoutAccessToken","isCurrentFlowCodeFlowWithRefreshTokens","useRefreshToken","flowTypes","responseType","some","CALLBACK_PARAMS_TO_CHECK","UrlService","flowsDataService","flowHelper","getUrlParameter","urlToCheck","name","regex","RegExp","results","exec","isCallbackFromSts","currentUrl","getRefreshSessionSilentRenewUrl","customParams","createUrlCodeFlowWithSilentRenew","createUrlImplicitFlowWithSilentRenew","getAuthorizeParUrl","requestUri","authWellKnownEndPoints","authorizationEndpoint","urlParts","authorizationUrl","existingParams","createHttpParams","append","getAuthorizeUrl","createUrlCodeFlowAuthorize","createUrlImplicitFlowAuthorize","createEndSessionUrl","idTokenHint","customParamsEndSession","endSessionEndpoint","authorizationEndSessionUrl","postLogoutRedirectUri","getPostLogoutRedirectUrl","appendCustomParams","assign","createRevocationEndpointBodyAccessToken","getClientId","createRevocationEndpointBodyRefreshToken","getRevocationEndpointUrl","revocationEndpoint","revocationEndpointUrl","createBodyForCodeFlowCodeRequest","code","customTokenParams","silentRenewUrl","getSilentRenewUrl","redirectUrl","getRedirectUrl","createBodyForCodeFlowRefreshTokensRequest","refreshToken","customParamsRefresh","createBodyForParCodeFlowRequest","customParamsRequest","codeChallenge","scope","hdParam","customParamsAuthRequest","createAuthorizeUrl","prompt","customRequestParams","mergedParams","fromString","encoder","CodeFlowCallbackHandlerService","urlService","dataService","codeFlowCallback","initialCallbackContext","isRenewProcess","jwtKeys","validationResult","existingIdToken","codeFlowCodeRequest","callbackContext","isStateCorrect","authWellknownEndpoints","tokenEndpoint","config","bodyForCodeFlow","customParamsCodeRequest","response","session_state","handleRefreshRetry","authority","errorMessage","errors","ProgressEvent","refreshTokenRetryInSeconds","DEFAULT_USERRESULT","userData","allUserData","UserService","oidcDataService","eventService","userDataInternal$","userData$","getAndPersistUserDataInStore","existingUserDataFromStorage","getUserDataFromStore","haveUserData","setUserDataToStore","renewUserInfoAfterTokenRenew","getUserDataOidcFlowAndSave","sub","publishUserDataIfExists","fireUserDataEvent","resetUserDataInStore","idTokenSub","getIdentityUserData","data","validateUserDataSubIdToken","userInfoEndpoint","userinfoEndpoint","userDataSub","passedUserData","composeSingleOrMultipleUserDataObject","UserDataChanged","composeSingleUserDataResult","currentConfigIsToUpdate","alreadySavedUserData","ResetAuthDataService","authStateService","userService","resetAuthorizationData","ImplicitFlowCallbackHandlerService","resetAuthDataService","implicitFlowCallback","isRenewProcessData","location","reduce","resultData","item","shift","ValidationResult","SigninKeyDataService","getSigningKeys","jwksUri","e","handleErrorGetSigningKeys","errorResponse","errMsg","status","statusText","JWT_KEYS","HistoryJwtKeysCallbackHandlerService","signInKeyDataService","callbackHistoryAndResetJwtKeys","historyCleanUpTurnedOn","resetBrowserHistory","handleResultErrorFromCallback","storeSigningKeys","storedJwtKeys","readSigningKeys","SecureTokenServerError","LoginRequired","historyCleanupOff","history","replaceState","document","title","origin","pathname","UserCallbackHandlerService","callbackUser","autoUserInfo","publishAuthState","publishUnauthenticatedState","stateValidationResult","StateValidationResult","authResponseIsValid","NotSet","EqualityService","isStringEqualOrNonOrderedArrayEqual","value1","value2","isNullOrUndefined","oneValueIsStringAndTheOtherIsArray","bothValuesAreStrings","bothValuesAreArrays","arraysHaveEqualContent","areEqual","arraysStrictEqual","bothValuesAreObjects","toLowerCase","valueIsString","valueIsObject","String","arr1","arr2","v","val","StateValidationService","equalityService","getValidatedStateResult","validateState","toReturn","StatesDoNotMatch","handleUnsuccessfulValidation","access_token","issValidationOff","maxIdTokenIatOffsetAllowedInSeconds","SignatureFailed","authNonce","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","issuer","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","IncorrectAzp","isIdTokenAfterRefreshTokenRequestValid","IncorrectIdTokenClaimsAfterRefresh","Ok","handleSuccessfulValidation","idTokenHeader","at_hash","IncorrectAtHash","newIdToken","disableRefreshIdTokenAuthTimeValidation","auth_time","autoCleanStateAfterAuthentication","StateValidationCallbackHandlerService","stateValidationService","callbackStateValidation","publishUnauthorizedState","RefreshSessionCallbackHandlerService","refreshSessionWithRefreshTokens","stateData","RefreshTokenCallbackHandlerService","refreshTokensRequestTokens","FlowsService","codeFlowCallbackHandlerService","implicitFlowCallbackHandlerService","historyJwtKeysCallbackHandlerService","userHandlerService","stateValidationCallbackHandlerService","refreshSessionCallbackHandlerService","refreshTokenCallbackHandlerService","processCodeFlowCallback","processSilentRenewCodeFlowCallback","firstContext","processImplicitFlowCallback","processRefreshToken","IntervalService","zone","runTokenValidationRunning","stopPeriodicTokenCheck","unsubscribe","startPeriodicTokenCheck","repeatAfterSeconds","millisecondsDelayBetweenTokenCheck","subscriber","intervalId","runOutsideAngular","setInterval","run","clearInterval","NgZone","providedIn","ImplicitFlowCallbackService","flowsService","intervalService","authenticatedImplicitFlowCallback","triggerAuthorizationResultEvent","postLoginRoute","unauthorizedRoute","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","createElement","id","style","display","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","CheckSessionService","iFrameService","checkSessionReceived","lastIFrameRefresh","outstandingMessages","heartBeatInterval","iframeRefreshInterval","checkSessionChangedInternal$","checkSessionChanged$","isCheckSessionConfigured","startCheckSession","start","scheduledHeartBeatRunning","pollServerSession","stop","clearScheduledHeartBeat","serverStateChanged","getExistingIframe","init","now","existingIframe","getOrCreateIframe","checkSessionIframe","contentWindow","observer","onload","complete","pollServerSessionRecur","subscribe","iframeOrigin","URL","postMessage","setTimeout","clearTimeout","messageHandler","existingIFrame","startsWith","source","CheckSessionReceived","bindMessageEventToIframe","iframeMessageEvent","bind","addEventListener","frame","CurrentUrlService","getStateParamFromCurrentUrl","getCurrentUrl","parsedUrl","urlParams","URLSearchParams","search","stateFromUrl","currentUrlHasStateParam","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","SilentRenewService","implicitFlowCallbackService","refreshSessionWithIFrameCompletedInternal$","refreshSessionWithIFrameCompleted$","isSilentRenewConfigured","silentRenew","codeFlowCallbackSilentRenewIframe","errorFromFlow","silentRenewEventHandler","detail","callback$","isCodeFlow","CodeFlowCallbackService","authenticatedCallbackWithCode","CallbackService","codeFlowCallbackService","stsCallbackInternal$","stsCallback$","isCallback","handleCallbackAndFireEvents","currentCallbackUrl","WELL_KNOWN_SUFFIX","AuthWellKnownDataService","getWellKnownEndPointsFromUrl","authWellknownEndpoint","getWellKnownDocument","wellKnownEndpoints","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspectionEndpoint","introspection_endpoint","parEndpoint","pushed_authorization_request_endpoint","wellKnownEndpoint","AuthWellKnownService","getAuthWellKnownEndPoints","authWellknownEndpointUrl","alreadySavedWellKnownEndpoints","mappedWellKnownEndpoints","storeWellKnownEndpoints","ConfigLoadingFailed","RefreshSessionIframeService","silentRenewService","rendererFactory","renderer","createRenderer","refreshSessionWithIframe","sendAuthorizeRequestUsingSilentRenew","initSilentRenewRequest","onLoadHandler","removeEventListener","instanceId","random","initDestroyHandler","listen","renewDestroyHandler","dispatchEvent","CustomEvent","RendererFactory2","RefreshSessionRefreshTokenService","MAX_RETRY_ATTEMPTS","RefreshSessionService","authWellKnownService","refreshSessionIframeService","refreshSessionRefreshTokenService","userForceRefreshSession","extraCustomParams","persistCustomParams","forceRefreshSession","customParamsRefreshTokenRequest","startRefreshSession","timeOutTime","timeoutRetryStrategy","_","_b","shouldBeExecuted","errorAttempts","scalingDuration","currentAttempt","PeriodicallyTokenCheckService","startTokenValidationPeriodically","configsWithSilentRenewEnabled","getConfigsWithSilentRenewEnabled","refreshTimeInSeconds","getSmallestRefreshTimeFromConfigs","periodicallyCheck$","objectWithConfigIdsAndRefreshEvent","forEach","getRefreshEvent","objectWithConfigIds","shouldStartRefreshEvent","shouldStartPeriodicallyCheckForConfig","refreshEvent$","createRefreshEventForConfig","SilentRenewStarted","refreshEventWithErrorHandler$","prev","curr","tokenRefreshInSeconds","filter","userDataFromStore","idTokenStillValid","accessTokenHasExpired","PopUpService","STORAGE_IDENTIFIER","resultInternal$","result$","isCurrentlyInPopup","canAccessSessionStorage","popup","sessionStorage","getItem","opener","openPopUp","popupOptions","optionsToPass","getOptions","popUp","open","setItem","listener","event","userClosed","receivedUrl","cleanUp","handle","closed","sendMessageToMainWindow","sendMessage","href","removeItem","close","popupDefaultOptions","width","height","left","top","options","navigator","cookieEnabled","Storage","CheckAuthService","checkSessionService","currentUrlService","callbackService","refreshSessionService","periodicallyTokenCheckService","popupService","autoLoginService","checkAuth","passedConfigId","stateParamFromUrl","getConfigurationWithUrlState","checkAuthWithConfig","onlyExistingConfig","checkAuthMultiple","composeMultipleLoginResults","allConfigs","allChecks$","checkAuthIncludingServer","loginResponse","loginResponseAfterRefreshSession","startCheckSessionAndValidation","storedState","activeConfig","allOtherConfigs","currentConfigResult","allOtherConfigResults","DEFAULT_CONFIG","usePushedAuthorisationRequests","forbiddenRoute","storage","customParamsEndSessionRequest","eagerLoadAuthWellKnownEndpoints","POSITIVE_VALIDATION_RESULT","messages","level","ensureAuthority","passedConfig","ensureClientId","createIdentifierToCheck","arrayHasDuplicates","array","Set","size","ensureNoDuplicatedConfigsRule","passedConfigs","allIdentifiers","hasDuplicates","ensureRedirectRule","ensureSilentRenewUrlWhenNoRefreshTokenUsed","usesSilentRenew","usesRefreshToken","hasSilentRenewUrl","useOfflineScopeWithSilentRenew","hasRefreshToken","hasSilentRenew","hasOfflineScope","allRules","allMultipleConfigRules","ConfigValidationService","validateConfigs","validateConfigsInternal","validateConfig","validateConfigInternal","allRulesToUse","allValidationResults","rule","overallErrorCount","errorCount","processValidationResultsAndGetErrorCount","allMessages","allErrorMessages","getAllMessagesOfType","allWarnings","acc","concat","PlatformProvider","platformId","isBrowser","OidcConfigService","configValidationService","platformProvider","withConfigs","Promise","resolve","createUniqueIds","allHandleConfigPromises","handleConfig","all","reject","usedConfig","prepareConfig","alreadyExistingAuthWellKnownEndpoints","ConfigLoaded","passedAuthWellKnownEndpoints","wellknownEndPoints","configuration","openIdConfigurationInternal","setSpecialCases","currentConfig","OpenIdConfigLoader","StsConfigLoader","StsConfigStaticLoader","loadConfigs","allInstantStaticPromises","singleStaticPromise","StsConfigHttpLoader","configs$","ClosestMatchingRouteService","configProvider","getConfigIdForClosestMatchingRoute","route","allConfiguredRoutes","getAllConfiguredRoutes","routesWithConfig","allRoutesForConfig","routes","configuredRoute","matchingRoute","matchingConfigId","allConfigurations","secureRoutes","ResponseTypeValidationService","hasConfigValidResponseType","RedirectService","redirectTo","ParService","postParRequest","expiresIn","request_uri","ParLoginService","responseTypeValidationService","redirectService","checkAuthService","parService","loginPar","authOptions","urlHandler","loginWithPopUpPar","PopUpLoginService","loginWithPopUpStandard","authUrl","StandardLoginService","loginStandard","LoginService","parLoginService","popUpLoginService","standardLoginService","login","loginWithPopUp","LogoffRevocationService","logoff","endSessionUrl","getEndSessionUrl","logoffLocal","logoffLocalMultiple","logoffAndRevokeTokens","revokeRefreshToken","revokeAccessToken","accessTok","sendRevokeRequest","refreshTok","OidcSecurityService","logoffRevocationService","loginService","isAuthenticated$","getConfigurations","getConfiguration","getUserData","getPayloadFromIdToken","encode","setState","getState","authorize","authorizeWithPopUp","BrowserStorageService","hasStorage","getStorage","createStaticLoader","configurationProviderFactory","oidcConfigService","loader","allLoadPromises","fn","then","PASSED_CONFIG","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","multi","useClass","ɵmod","ɵinj","imports","declarations","exports","AutoLoginAllRoutesGuard","canLoad","segments","routeToRedirect","canActivate","getId","AutoLoginPartialRoutesGuard","AuthInterceptor","closestMatchingRouteService","intercept","req","allRoutesConfigured","allRoutesConfiguredFlat","apply","clone"],"mappings":"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","sourcesContent":["import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { ReplaySubject, BehaviorSubject, throwError, of, timer, Observable, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { distinctUntilChanged, switchMap, retryWhen, catchError, mergeMap, map, retry, tap, concatMap, take, timeout } from 'rxjs/operators';\nimport { KJUR, hextob64u, KEYUTIL } from 'jsrsasign-reduced';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    get(url, params) {\r\n        return this.http.get(url, params);\r\n    }\r\n    post(url, body, params) {\r\n        return this.http.post(url, body, params);\r\n    }\r\n}\r\nHttpBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHttpBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HttpBaseService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });\n\nclass ConfigurationProvider {\r\n    constructor() {\r\n        this.configsInternal = {};\r\n    }\r\n    hasAsLeastOneConfig() {\r\n        return Object.keys(this.configsInternal).length > 0;\r\n    }\r\n    hasManyConfigs() {\r\n        return Object.keys(this.configsInternal).length > 1;\r\n    }\r\n    setConfig(readyConfig) {\r\n        const { configId } = readyConfig;\r\n        this.configsInternal[configId] = readyConfig;\r\n    }\r\n    getOpenIDConfiguration(configId) {\r\n        if (!!configId) {\r\n            return this.configsInternal[configId] || null;\r\n        }\r\n        const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\r\n        return value || null;\r\n    }\r\n    getAllConfigurations() {\r\n        return Object.values(this.configsInternal);\r\n    }\r\n}\r\nConfigurationProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigurationProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigurationProvider, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\r\nclass DataService {\r\n    constructor(httpClient, configurationProvider) {\r\n        this.httpClient = httpClient;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    get(url, configId, token) {\r\n        const headers = this.prepareHeaders(token);\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.get(url, {\r\n            headers,\r\n            params,\r\n        });\r\n    }\r\n    post(url, body, configId, headersParams) {\r\n        const headers = headersParams || this.prepareHeaders();\r\n        const params = this.prepareParams(configId);\r\n        return this.httpClient.post(url, body, { headers, params });\r\n    }\r\n    prepareHeaders(token) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        if (!!token) {\r\n            headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n        }\r\n        return headers;\r\n    }\r\n    prepareParams(configId) {\r\n        let params = new HttpParams();\r\n        const { ngswBypass } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (ngswBypass) {\r\n            params = params.set(NGSW_CUSTOM_PARAM, '');\r\n        }\r\n        return params;\r\n    }\r\n}\r\nDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService, deps: [{ token: HttpBaseService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: DataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: HttpBaseService }, { type: ConfigurationProvider }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar EventTypes;\r\n(function (EventTypes) {\r\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\r\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\r\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 1] = \"ConfigLoadingFailed\";\r\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 2] = \"CheckSessionReceived\";\r\n    EventTypes[EventTypes[\"UserDataChanged\"] = 3] = \"UserDataChanged\";\r\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 4] = \"NewAuthenticationResult\";\r\n    EventTypes[EventTypes[\"TokenExpired\"] = 5] = \"TokenExpired\";\r\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 6] = \"IdTokenExpired\";\r\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 7] = \"SilentRenewStarted\";\r\n})(EventTypes || (EventTypes = {}));\n\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\nclass AbstractSecurityStorage {\r\n}\r\nAbstractSecurityStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractSecurityStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AbstractSecurityStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StoragePersistenceService {\r\n    constructor(oidcSecurityStorage) {\r\n        this.oidcSecurityStorage = oidcSecurityStorage;\r\n    }\r\n    read(key, configId) {\r\n        const storedConfig = this.oidcSecurityStorage.read(configId) || {};\r\n        return storedConfig[key];\r\n    }\r\n    write(key, value, configId) {\r\n        const storedConfig = this.oidcSecurityStorage.read(configId) || {};\r\n        storedConfig[key] = value;\r\n        this.oidcSecurityStorage.write(configId, storedConfig);\r\n    }\r\n    remove(key, configId) {\r\n        const storedConfig = this.oidcSecurityStorage.read(configId) || {};\r\n        delete storedConfig[key];\r\n        this.oidcSecurityStorage.write(configId, storedConfig);\r\n    }\r\n    clear() {\r\n        this.oidcSecurityStorage.clear();\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.remove('session_state', configId);\r\n        this.remove('storageSilentRenewRunning', configId);\r\n        this.remove('codeVerifier', configId);\r\n        this.remove('userData', configId);\r\n        this.remove('storageCustomParamsAuthRequest', configId);\r\n        this.remove('access_token_expires_at', configId);\r\n        this.remove('storageCustomParamsRefresh', configId);\r\n        this.remove('storageCustomParamsEndSession', configId);\r\n    }\r\n    resetAuthStateInStorage(configId) {\r\n        this.remove('authzData', configId);\r\n        this.remove('authnResult', configId);\r\n    }\r\n    getAccessToken(configId) {\r\n        return this.read('authzData', configId);\r\n    }\r\n    getIdToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.id_token;\r\n    }\r\n    getRefreshToken(configId) {\r\n        var _a;\r\n        return (_a = this.read('authnResult', configId)) === null || _a === void 0 ? void 0 : _a.refresh_token;\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        return this.read('authnResult', configId);\r\n    }\r\n}\r\nStoragePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService, deps: [{ token: AbstractSecurityStorage }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStoragePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StoragePersistenceService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AbstractSecurityStorage }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n})(LogLevel || (LogLevel = {}));\n\nclass LoggerService {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    logError(configId, message, ...args) {\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!!args && args.length) {\r\n            console.error(`[ERROR] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.error(`[ERROR] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logWarning(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Warn)) {\r\n            return;\r\n        }\r\n        if (!!args && args.length) {\r\n            console.warn(`[WARN] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.warn(`[WARN] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    logDebug(configId, message, ...args) {\r\n        if (!this.logLevelIsSet(configId)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configId)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configId, LogLevel.Debug)) {\r\n            return;\r\n        }\r\n        if (!!args && args.length) {\r\n            console.log(`[DEBUG] ${configId} - ${message}`, ...args);\r\n        }\r\n        else {\r\n            console.log(`[DEBUG] ${configId} - ${message}`);\r\n        }\r\n    }\r\n    currentLogLevelIsEqualOrSmallerThan(configId, logLevelToCompare) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel <= logLevelToCompare;\r\n    }\r\n    logLevelIsSet(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (logLevel === null) {\r\n            return false;\r\n        }\r\n        if (logLevel === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    loggingIsTurnedOff(configId) {\r\n        const { logLevel } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        return logLevel === LogLevel.None;\r\n    }\r\n}\r\nLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoggerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass PublicEventsService {\r\n    constructor() {\r\n        this.notify = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\r\n    fireEvent(type, value) {\r\n        this.notify.next({ type, value });\r\n    }\r\n    /**\r\n     * Wires up the event notification observable.\r\n     */\r\n    registerForEvents() {\r\n        return this.notify.asObservable();\r\n    }\r\n}\r\nPublicEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPublicEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PublicEventsService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst PARTS_OF_TOKEN = 3;\r\nclass TokenHelperService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    getTokenExpirationDate(dataIdToken) {\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            return new Date(new Date().toUTCString());\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n        return date;\r\n    }\r\n    getHeaderFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n    getPayloadFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n    getSignatureFromToken(token, encoded, configId) {\r\n        if (!this.tokenIsValid(token, configId)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n    getPartOfToken(token, index, encoded) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n        const decoded = typeof window !== 'undefined' ? window.atob(output) : Buffer.from(output, 'base64').toString('binary');\r\n        try {\r\n            // Going backwards: from byte stream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded\r\n                .split('')\r\n                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        }\r\n        catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n    tokenIsValid(token, configId) {\r\n        if (!token) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n        if (!token.includes('.')) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(configId, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    extractPartOfToken(token, index) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\nTokenHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenHelperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass JsrsAsignReducedService {\r\n    generateCodeChallenge(codeVerifier) {\r\n        const hash = KJUR.crypto.Util.hashString(codeVerifier, 'sha256');\r\n        const testData = hextob64u(hash);\r\n        return testData;\r\n    }\r\n    generateAtHash(accessToken, sha) {\r\n        const hash = KJUR.crypto.Util.hashString(accessToken, sha);\r\n        const first128bits = hash.substr(0, hash.length / 2);\r\n        const testData = hextob64u(first128bits);\r\n        return testData;\r\n    }\r\n}\r\nJsrsAsignReducedService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nJsrsAsignReducedService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: JsrsAsignReducedService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\r\n// Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\r\n// in the ID Token.\r\nclass TokenValidationService {\r\n    constructor(tokenHelperService, loggerService, jsrsAsignReducedService) {\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.jsrsAsignReducedService = jsrsAsignReducedService;\r\n        this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    hasIdTokenExpired(token, configId, offsetSeconds) {\r\n        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configId);\r\n        return !this.validateIdTokenExpNotExpired(decoded, configId, offsetSeconds);\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    validateIdTokenExpNotExpired(decodedIdToken, configId, offsetSeconds) {\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // Token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configId, offsetSeconds) {\r\n        // value is optional, so if it does not exist, then it has not expired\r\n        if (!accessTokenExpiresAt) {\r\n            return true;\r\n        }\r\n        offsetSeconds = offsetSeconds || 0;\r\n        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\r\n        const nowWithOffset = new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configId, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        // access token not expired?\r\n        return tokenNotExpired;\r\n    }\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\r\n    // https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\r\n    // audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\r\n    // the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\r\n    // 1970- 01 - 01T00: 00: 00Z as measured\r\n    // in UTC until the date/ time.\r\n    validateRequiredIdToken(dataIdToken, configId) {\r\n        let validated = true;\r\n        if (!dataIdToken.hasOwnProperty('iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iss is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'sub is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'aud is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'exp is missing, this is required in the id_token');\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configId, 'iat is missing, this is required in the id_token');\r\n        }\r\n        return validated;\r\n    }\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configId) {\r\n        if (disableIatOffsetValidation) {\r\n            return true;\r\n        }\r\n        if (!dataIdToken.hasOwnProperty('iat')) {\r\n            return false;\r\n        }\r\n        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\r\n        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\r\n        const nowInUtc = new Date(new Date().toUTCString());\r\n        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\r\n        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\r\n        this.loggerService.logDebug(configId, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\r\n        if (diff > 0) {\r\n            return diff < maxOffsetAllowedInMilliseconds;\r\n        }\r\n        return -diff < maxOffsetAllowedInMilliseconds;\r\n    }\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and KeyCloak does send it.\r\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configId) {\r\n        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configId) {\r\n        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                dataIdToken.iss +\r\n                ' authWellKnownEndpoints issuer:' +\r\n                authWellKnownEndpointsIssuer);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validateIdTokenAud(dataIdToken, aud, configId) {\r\n        if (Array.isArray(dataIdToken.aud)) {\r\n            const result = dataIdToken.aud.includes(aud);\r\n            if (!result) {\r\n                this.loggerService.logDebug(configId, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug(configId, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\r\n        if (!dataIdToken) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n    validateIdTokenAzpValid(dataIdToken, clientId) {\r\n        if (!(dataIdToken === null || dataIdToken === void 0 ? void 0 : dataIdToken.azp)) {\r\n            return true;\r\n        }\r\n        if (dataIdToken.azp === clientId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    validateStateFromHashCallback(state, localState, configId) {\r\n        if (state !== localState) {\r\n            this.loggerService.logDebug(configId, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validateSignatureIdToken(idToken, jwtkeys, configId) {\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return false;\r\n        }\r\n        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configId);\r\n        if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\r\n            this.loggerService.logWarning(configId, 'id token has no header data');\r\n            return false;\r\n        }\r\n        const kid = headerData.kid;\r\n        const alg = headerData.alg;\r\n        if (!this.keyAlgorithms.includes(alg)) {\r\n            this.loggerService.logWarning(configId, 'alg not supported', alg);\r\n            return false;\r\n        }\r\n        let jwtKtyToUse = 'RSA';\r\n        if (alg.charAt(0) === 'E') {\r\n            jwtKtyToUse = 'EC';\r\n        }\r\n        let isValid = false;\r\n        // No kid in the Jose header\r\n        if (!kid) {\r\n            let keyToValidate;\r\n            // If only one key, use it\r\n            if (jwtkeys.keys.length === 1 && jwtkeys.keys[0].kty === jwtKtyToUse) {\r\n                keyToValidate = jwtkeys.keys[0];\r\n            }\r\n            else {\r\n                // More than one key\r\n                // Make sure there's exactly 1 key candidate\r\n                // kty \"RSA\" and \"EC\" uses \"sig\"\r\n                let amountOfMatchingKeys = 0;\r\n                for (const key of jwtkeys.keys) {\r\n                    if (key.kty === jwtKtyToUse && key.use === 'sig') {\r\n                        amountOfMatchingKeys++;\r\n                        keyToValidate = key;\r\n                    }\r\n                }\r\n                if (amountOfMatchingKeys > 1) {\r\n                    this.loggerService.logWarning(configId, 'no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\r\n                    return false;\r\n                }\r\n            }\r\n            if (!keyToValidate) {\r\n                this.loggerService.logWarning(configId, 'no keys found, incorrect Signature, validation failed for id_token');\r\n                return false;\r\n            }\r\n            isValid = KJUR.jws.JWS.verify(idToken, KEYUTIL.getKey(keyToValidate), [alg]);\r\n            if (!isValid) {\r\n                this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\r\n            }\r\n            return isValid;\r\n        }\r\n        else {\r\n            // kid in the Jose header of id_token\r\n            for (const key of jwtkeys.keys) {\r\n                if (key.kid === kid) {\r\n                    const publicKey = KEYUTIL.getKey(key);\r\n                    isValid = KJUR.jws.JWS.verify(idToken, publicKey, [alg]);\r\n                    if (!isValid) {\r\n                        this.loggerService.logWarning(configId, 'incorrect Signature, validation failed for id_token');\r\n                    }\r\n                    return isValid;\r\n                }\r\n            }\r\n        }\r\n        return isValid;\r\n    }\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n    ////    return true;\r\n    //// }\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configId) {\r\n        this.loggerService.logDebug(configId, 'at_hash from the server:' + atHash);\r\n        // 'sha256' 'sha384' 'sha512'\r\n        let sha = 'sha256';\r\n        if (idTokenAlg.includes('384')) {\r\n            sha = 'sha384';\r\n        }\r\n        else if (idTokenAlg.includes('512')) {\r\n            sha = 'sha512';\r\n        }\r\n        const testData = this.jsrsAsignReducedService.generateAtHash('' + accessToken, sha);\r\n        this.loggerService.logDebug(configId, 'at_hash client validation not decoded:' + testData);\r\n        if (testData === atHash) {\r\n            return true; // isValid;\r\n        }\r\n        else {\r\n            const testValue = this.jsrsAsignReducedService.generateAtHash('' + decodeURIComponent(accessToken), sha);\r\n            this.loggerService.logDebug(configId, '-gen access--' + testValue);\r\n            if (testValue === atHash) {\r\n                return true; // isValid\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    millisToMinutesAndSeconds(millis) {\r\n        const minutes = Math.floor(millis / 60000);\r\n        const seconds = ((millis % 60000) / 1000).toFixed(0);\r\n        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\r\n    }\r\n}\r\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\r\nTokenValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JsrsAsignReducedService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: TokenValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: TokenHelperService }, { type: LoggerService }, { type: JsrsAsignReducedService }]; } });\n\nconst DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };\r\nclass AuthStateService {\r\n    constructor(storagePersistenceService, loggerService, publicEventsService, configurationProvider, tokenValidationService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\r\n    }\r\n    get authenticated$() {\r\n        return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n    setAuthenticatedAndFireEvent() {\r\n        const result = this.composeAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    setUnauthenticatedAndFireEvent(configIdToReset) {\r\n        this.storagePersistenceService.resetAuthStateInStorage(configIdToReset);\r\n        const result = this.composeUnAuthenticatedResult();\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    updateAndPublishAuthState(authenticationResult) {\r\n        this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\r\n    }\r\n    setAuthorizationData(accessToken, authResult, configId) {\r\n        this.loggerService.logDebug(configId, `storing the accessToken '${accessToken}'`);\r\n        this.storagePersistenceService.write('authzData', accessToken, configId);\r\n        this.persistAccessTokenExpirationTime(authResult, configId);\r\n        this.setAuthenticatedAndFireEvent();\r\n    }\r\n    getAccessToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getIdToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getIdToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getRefreshToken(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getRefreshToken(configId);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getAuthenticationResult(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return null;\r\n        }\r\n        return this.storagePersistenceService.getAuthenticationResult(configId);\r\n    }\r\n    areAuthStorageTokensValid(configId) {\r\n        if (!this.isAuthenticated(configId)) {\r\n            return false;\r\n        }\r\n        if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted idToken is expired');\r\n            return false;\r\n        }\r\n        if (this.hasAccessTokenExpiredIfExpiryExists(configId)) {\r\n            this.loggerService.logDebug(configId, 'persisted accessToken is expired');\r\n            return false;\r\n        }\r\n        this.loggerService.logDebug(configId, 'persisted idToken and accessToken are valid');\r\n        return true;\r\n    }\r\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds, enableIdTokenExpiredValidationInRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!enableIdTokenExpiredValidationInRenew) {\r\n            return false;\r\n        }\r\n        const tokenToCheck = this.storagePersistenceService.getIdToken(configId);\r\n        const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        if (idTokenExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\r\n        }\r\n        return idTokenExpired;\r\n    }\r\n    hasAccessTokenExpiredIfExpiryExists(configId) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configId);\r\n        const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configId, renewTimeBeforeTokenExpiresInSeconds);\r\n        const hasExpired = !accessTokenHasNotExpired;\r\n        if (hasExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\r\n        }\r\n        return hasExpired;\r\n    }\r\n    isAuthenticated(configId) {\r\n        return !!this.storagePersistenceService.getAccessToken(configId) && !!this.storagePersistenceService.getIdToken(configId);\r\n    }\r\n    decodeURIComponentSafely(token) {\r\n        if (token) {\r\n            return decodeURIComponent(token);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    persistAccessTokenExpirationTime(authResult, configId) {\r\n        if (authResult === null || authResult === void 0 ? void 0 : authResult.expires_in) {\r\n            const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\r\n            this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configId);\r\n        }\r\n    }\r\n    composeAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: true, allConfigsAuthenticated: [{ configId, isAuthenticated: true }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    composeUnAuthenticatedResult() {\r\n        if (!this.configurationProvider.hasManyConfigs()) {\r\n            const { configId } = this.configurationProvider.getOpenIDConfiguration();\r\n            return { isAuthenticated: false, allConfigsAuthenticated: [{ configId, isAuthenticated: false }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated();\r\n    }\r\n    checkAllConfigsIfTheyAreAuthenticated() {\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allConfigsAuthenticated = configs.map(({ configId }) => ({\r\n            configId,\r\n            isAuthenticated: this.isAuthenticated(configId),\r\n        }));\r\n        const isAuthenticated = allConfigsAuthenticated.every((x) => !!x.isAuthenticated);\r\n        return { allConfigsAuthenticated, isAuthenticated };\r\n    }\r\n}\r\nAuthStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: TokenValidationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthStateService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: TokenValidationService }]; } });\n\nconst STORAGE_KEY = 'redirect';\r\nclass AutoLoginService {\r\n    constructor(storageService, router) {\r\n        this.storageService = storageService;\r\n        this.router = router;\r\n    }\r\n    checkSavedRedirectRouteAndNavigate(configId) {\r\n        const savedRouteForRedirect = this.getStoredRedirectRoute(configId);\r\n        if (savedRouteForRedirect) {\r\n            this.deleteStoredRedirectRoute(configId);\r\n            this.router.navigateByUrl(savedRouteForRedirect);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the redirect url to storage.\r\n     *\r\n     * @param url The redirect url to save.\r\n     */\r\n    saveRedirectRoute(configId, url) {\r\n        this.storageService.write(STORAGE_KEY, url, configId);\r\n    }\r\n    /**\r\n     * Gets the stored redirect route from storage.\r\n     */\r\n    getStoredRedirectRoute(configId) {\r\n        return this.storageService.read(STORAGE_KEY, configId);\r\n    }\r\n    /**\r\n     * Removes the redirect url from storage.\r\n     */\r\n    deleteStoredRedirectRoute(configId) {\r\n        this.storageService.remove(STORAGE_KEY, configId);\r\n    }\r\n}\r\nAutoLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2.Router }]; } });\n\nclass UriEncoder {\r\n    encodeKey(key) {\r\n        return encodeURIComponent(key);\r\n    }\r\n    encodeValue(value) {\r\n        return encodeURIComponent(value);\r\n    }\r\n    decodeKey(key) {\r\n        return decodeURIComponent(key);\r\n    }\r\n    decodeValue(value) {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\n\nclass RandomService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createRandom(requiredLength, configId) {\r\n        if (requiredLength <= 0) {\r\n            return '';\r\n        }\r\n        if (requiredLength > 0 && requiredLength < 7) {\r\n            this.loggerService.logWarning(configId, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\r\n            requiredLength = 10;\r\n        }\r\n        const length = requiredLength - 6;\r\n        const arr = new Uint8Array(Math.floor((length || length) / 2));\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(arr);\r\n        }\r\n        return Array.from(arr, this.toHex).join('') + this.randomString(7);\r\n    }\r\n    toHex(dec) {\r\n        return ('0' + dec.toString(16)).substr(-2);\r\n    }\r\n    randomString(length) {\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const values = new Uint32Array(length);\r\n        if (this.getCrypto()) {\r\n            this.getCrypto().getRandomValues(values);\r\n            for (let i = 0; i < length; i++) {\r\n                result += characters[values[i] % characters.length];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    getCrypto() {\r\n        // support for IE,  (window.crypto || window.msCrypto)\r\n        return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\r\n    }\r\n}\r\nRandomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRandomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RandomService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }]; } });\n\nclass FlowsDataService {\r\n    constructor(storagePersistenceService, randomService, configurationProvider, loggerService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.randomService = randomService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createNonce(configId) {\r\n        const nonce = this.randomService.createRandom(40, configId);\r\n        this.setNonce(nonce, configId);\r\n        return nonce;\r\n    }\r\n    setNonce(nonce, configId) {\r\n        this.storagePersistenceService.write('authNonce', nonce, configId);\r\n    }\r\n    getAuthStateControl(configId) {\r\n        return this.storagePersistenceService.read('authStateControl', configId);\r\n    }\r\n    setAuthStateControl(authStateControl, configId) {\r\n        this.storagePersistenceService.write('authStateControl', authStateControl, configId);\r\n    }\r\n    getExistingOrCreateAuthStateControl(configId) {\r\n        let state = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!state) {\r\n            state = this.randomService.createRandom(40, configId);\r\n            this.storagePersistenceService.write('authStateControl', state, configId);\r\n        }\r\n        return state;\r\n    }\r\n    setSessionState(sessionState, configId) {\r\n        this.storagePersistenceService.write('session_state', sessionState, configId);\r\n    }\r\n    resetStorageFlowData(configId) {\r\n        this.storagePersistenceService.resetStorageFlowData(configId);\r\n    }\r\n    getCodeVerifier(configId) {\r\n        return this.storagePersistenceService.read('codeVerifier', configId);\r\n    }\r\n    createCodeVerifier(configId) {\r\n        const codeVerifier = this.randomService.createRandom(67, configId);\r\n        this.storagePersistenceService.write('codeVerifier', codeVerifier, configId);\r\n        return codeVerifier;\r\n    }\r\n    isSilentRenewRunning(configId) {\r\n        const storageObject = this.getSilentRenewRunningStorageEntry(configId);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\r\n        const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\r\n        const currentDateUtc = Date.parse(new Date().toISOString());\r\n        const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\r\n        const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\r\n        if (isProbablyStuck) {\r\n            this.loggerService.logDebug(configId, 'silent renew process is probably stuck, state will be reset.', configId);\r\n            this.resetSilentRenewRunning(configId);\r\n            return false;\r\n        }\r\n        return storageObject.state === 'running';\r\n    }\r\n    setSilentRenewRunning(configId) {\r\n        const storageObject = {\r\n            state: 'running',\r\n            dateOfLaunchedProcessUtc: new Date().toISOString(),\r\n        };\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configId);\r\n    }\r\n    resetSilentRenewRunning(configId) {\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', '', configId);\r\n    }\r\n    getSilentRenewRunningStorageEntry(configId) {\r\n        const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configId);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n}\r\nFlowsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: ConfigurationProvider }, { type: LoggerService }]; } });\n\nclass FlowHelper {\r\n    constructor(configurationProvider) {\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    isCurrentFlowCodeFlow(configId) {\r\n        return this.currentFlowIs('code', configId);\r\n    }\r\n    isCurrentFlowAnyImplicitFlow(configId) {\r\n        return this.isCurrentFlowImplicitFlowWithAccessToken(configId) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configId);\r\n    }\r\n    isCurrentFlowCodeFlowWithRefreshTokens(configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (this.isCurrentFlowCodeFlow(configId) && useRefreshToken) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCurrentFlowImplicitFlowWithAccessToken(configId) {\r\n        return this.currentFlowIs('id_token token', configId);\r\n    }\r\n    currentFlowIs(flowTypes, configId) {\r\n        const { responseType } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (Array.isArray(flowTypes)) {\r\n            return flowTypes.some((x) => responseType === x);\r\n        }\r\n        return responseType === flowTypes;\r\n    }\r\n    isCurrentFlowImplicitFlowWithoutAccessToken(configId) {\r\n        return this.currentFlowIs('id_token', configId);\r\n    }\r\n}\r\nFlowHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowHelper, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\r\nclass UrlService {\r\n    constructor(configurationProvider, loggerService, flowsDataService, flowHelper, storagePersistenceService, jsrsAsignReducedService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.jsrsAsignReducedService = jsrsAsignReducedService;\r\n    }\r\n    getUrlParameter(urlToCheck, name) {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n        if (!name) {\r\n            return '';\r\n        }\r\n        name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n    isCallbackFromSts(currentUrl) {\r\n        return CALLBACK_PARAMS_TO_CHECK.some((x) => !!this.getUrlParameter(currentUrl, x));\r\n    }\r\n    getRefreshSessionSilentRenewUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowWithSilentRenew(configId, customParams);\r\n        }\r\n        return this.createUrlImplicitFlowWithSilentRenew(configId, customParams) || '';\r\n    }\r\n    getAuthorizeParUrl(requestUri, configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }\r\n        const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize url when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('request_uri', requestUri);\r\n        params = params.append('client_id', clientId);\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    getAuthorizeUrl(configId, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return this.createUrlCodeFlowAuthorize(configId, customParams);\r\n        }\r\n        return this.createUrlImplicitFlowAuthorize(configId, customParams) || '';\r\n    }\r\n    createEndSessionUrl(idTokenHint, configId, customParamsEndSession) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const endSessionEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.endSessionEndpoint;\r\n        if (!endSessionEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = endSessionEndpoint.split('?');\r\n        const authorizationEndSessionUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('id_token_hint', idTokenHint);\r\n        const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configId);\r\n        if (postLogoutRedirectUri) {\r\n            params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\r\n        }\r\n        if (customParamsEndSession) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsEndSession), params);\r\n        }\r\n        return `${authorizationEndSessionUrl}?${params}`;\r\n    }\r\n    createRevocationEndpointBodyAccessToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'access_token');\r\n        return params.toString();\r\n    }\r\n    createRevocationEndpointBodyRefreshToken(token, configId) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'refresh_token');\r\n        return params.toString();\r\n    }\r\n    getRevocationEndpointUrl(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const revocationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.revocationEndpoint;\r\n        if (!revocationEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = revocationEndpoint.split('?');\r\n        const revocationEndpointUrl = urlParts[0];\r\n        return revocationEndpointUrl;\r\n    }\r\n    createBodyForCodeFlowCodeRequest(code, configId, customTokenParams) {\r\n        const codeVerifier = this.flowsDataService.getCodeVerifier(configId);\r\n        if (!codeVerifier) {\r\n            this.loggerService.logError(configId, `CodeVerifier is not set `, codeVerifier);\r\n            return null;\r\n        }\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'authorization_code');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('code_verifier', codeVerifier);\r\n        params = params.set('code', code);\r\n        if (customTokenParams) {\r\n            params = this.appendCustomParams(Object.assign({}, customTokenParams), params);\r\n        }\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (this.flowsDataService.isSilentRenewRunning(configId) && silentRenewUrl) {\r\n            params = params.set('redirect_uri', silentRenewUrl);\r\n            return params.toString();\r\n        }\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        params = params.set('redirect_uri', redirectUrl);\r\n        return params.toString();\r\n    }\r\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configId, customParamsRefresh) {\r\n        const clientId = this.getClientId(configId);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'refresh_token');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('refresh_token', refreshToken);\r\n        if (customParamsRefresh) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRefresh), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createBodyForParCodeFlowRequest(configId, customParamsRequest) {\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        let params = this.createHttpParams('');\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        params = params.append('code_challenge', codeChallenge);\r\n        params = params.append('code_challenge_method', 'S256');\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        if (customParamsAuthRequest) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsAuthRequest), params);\r\n        }\r\n        if (customParamsRequest) {\r\n            params = this.appendCustomParams(Object.assign({}, customParamsRequest), params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, prompt, customRequestParams) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const authorizationEndpoint = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configId, `Can not create an authorize url when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        if (!responseType) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add responseType because it was: `, responseType);\r\n            return null;\r\n        }\r\n        if (!scope) {\r\n            this.loggerService.logError(configId, `createAuthorizeUrl could not add scope because it was: `, scope);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n        if (prompt) {\r\n            params = params.append('prompt', prompt);\r\n        }\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsAuthRequest), customRequestParams);\r\n        if (Object.keys(mergedParams).length > 0) {\r\n            params = this.appendCustomParams(Object.assign({}, mergedParams), params);\r\n        }\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    createUrlImplicitFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ', state);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowWithSilentRenew(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configId);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configId, 'none', customParams);\r\n        }\r\n        this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlImplicitFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', redirectUrl, nonce, state, configId, null, customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowAuthorize(configId, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        const nonce = this.flowsDataService.createNonce(configId);\r\n        this.loggerService.logDebug(configId, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configId);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configId);\r\n        const codeChallenge = this.jsrsAsignReducedService.generateCodeChallenge(codeVerifier);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configId, null, customParams);\r\n        }\r\n        this.loggerService.logError(configId, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    getRedirectUrl(configId) {\r\n        const { redirectUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!redirectUrl) {\r\n            this.loggerService.logError(configId, `could not get redirectUrl, was: `, redirectUrl);\r\n            null;\r\n        }\r\n        return redirectUrl;\r\n    }\r\n    getSilentRenewUrl(configId) {\r\n        const { silentRenewUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!silentRenewUrl) {\r\n            this.loggerService.logError(configId, `could not get silentRenewUrl, was: `, silentRenewUrl);\r\n            return null;\r\n        }\r\n        return silentRenewUrl;\r\n    }\r\n    getPostLogoutRedirectUrl(configId) {\r\n        const { postLogoutRedirectUri } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!postLogoutRedirectUri) {\r\n            this.loggerService.logError(configId, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\r\n            return null;\r\n        }\r\n        return postLogoutRedirectUri;\r\n    }\r\n    getClientId(configId) {\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!clientId) {\r\n            this.loggerService.logError(configId, `could not get clientId, was: `, clientId);\r\n            return null;\r\n        }\r\n        return clientId;\r\n    }\r\n    appendCustomParams(customParams, params) {\r\n        for (const [key, value] of Object.entries(Object.assign({}, customParams))) {\r\n            params = params.append(key, value.toString());\r\n        }\r\n        return params;\r\n    }\r\n    createHttpParams(existingParams) {\r\n        existingParams = existingParams !== null && existingParams !== void 0 ? existingParams : '';\r\n        const params = new HttpParams({\r\n            fromString: existingParams,\r\n            encoder: new UriEncoder(),\r\n        });\r\n        return params;\r\n    }\r\n}\r\nUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JsrsAsignReducedService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JsrsAsignReducedService }]; } });\n\nclass CodeFlowCallbackHandlerService {\r\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, configurationProvider, storagePersistenceService, dataService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.dataService = dataService;\r\n    }\r\n    // STEP 1 Code Flow\r\n    codeFlowCallback(urlToCheck, configId) {\r\n        const code = this.urlService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state') || null;\r\n        if (!state) {\r\n            this.loggerService.logDebug(configId, 'no state in url');\r\n            return throwError('no state in url');\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug(configId, 'no code in url');\r\n            return throwError('no code in url');\r\n        }\r\n        this.loggerService.logDebug(configId, 'running validation for callback', urlToCheck);\r\n        const initialCallbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: false,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(initialCallbackContext);\r\n    }\r\n    // STEP 2 Code Flow //  Code Flow Silent Renew starts here\r\n    codeFlowCodeRequest(callbackContext, configId) {\r\n        const authStateControl = this.flowsDataService.getAuthStateControl(configId);\r\n        const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, configId);\r\n        if (!isStateCorrect) {\r\n            return throwError('codeFlowCodeRequest incorrect state');\r\n        }\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError('Token Endpoint not defined');\r\n        }\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, configId, config === null || config === void 0 ? void 0 : config.customParamsCodeRequest);\r\n        return this.dataService.post(tokenEndpoint, bodyForCodeFlow, configId, headers).pipe(switchMap((response) => {\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            authResult.session_state = callbackContext.sessionState;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: ConfigurationProvider }, { token: StoragePersistenceService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: ConfigurationProvider }, { type: StoragePersistenceService }, { type: DataService }]; } });\n\nconst DEFAULT_USERRESULT = { userData: null, allUserData: [] };\r\nclass UserService {\r\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper, configurationProvider) {\r\n        this.oidcDataService = oidcDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.eventService = eventService;\r\n        this.loggerService = loggerService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\r\n    }\r\n    get userData$() {\r\n        return this.userDataInternal$.asObservable();\r\n    }\r\n    getAndPersistUserDataInStore(configId, isRenewProcess = false, idToken, decodedIdToken) {\r\n        idToken = idToken || this.storagePersistenceService.getIdToken(configId);\r\n        decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, configId);\r\n        const existingUserDataFromStorage = this.getUserDataFromStore(configId);\r\n        const haveUserData = !!existingUserDataFromStorage;\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        const accessToken = this.storagePersistenceService.getAccessToken(configId);\r\n        if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\r\n            this.loggerService.logDebug(configId, `authCallback idToken flow with accessToken ${accessToken}`);\r\n            this.setUserDataToStore(decodedIdToken, configId);\r\n            return of(decodedIdToken);\r\n        }\r\n        const { renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\r\n            return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, configId).pipe(switchMap((userData) => {\r\n                this.loggerService.logDebug(configId, 'Received user data: ', userData);\r\n                if (!!userData) {\r\n                    this.loggerService.logDebug(configId, 'accessToken: ', accessToken);\r\n                    return of(userData);\r\n                }\r\n                else {\r\n                    return throwError('Received no user data, request failed');\r\n                }\r\n            }));\r\n        }\r\n        return of(existingUserDataFromStorage);\r\n    }\r\n    getUserDataFromStore(configId) {\r\n        return this.storagePersistenceService.read('userData', configId) || null;\r\n    }\r\n    publishUserDataIfExists(configId) {\r\n        const userData = this.getUserDataFromStore(configId);\r\n        if (userData) {\r\n            this.fireUserDataEvent(configId, userData);\r\n        }\r\n    }\r\n    setUserDataToStore(userData, configId) {\r\n        this.storagePersistenceService.write('userData', userData, configId);\r\n        this.fireUserDataEvent(configId, userData);\r\n    }\r\n    resetUserDataInStore(configId) {\r\n        this.storagePersistenceService.remove('userData', configId);\r\n        this.fireUserDataEvent(configId, null);\r\n    }\r\n    getUserDataOidcFlowAndSave(idTokenSub, configId) {\r\n        return this.getIdentityUserData(configId).pipe(map((data) => {\r\n            if (this.validateUserDataSubIdToken(idTokenSub, data === null || data === void 0 ? void 0 : data.sub)) {\r\n                this.setUserDataToStore(data, configId);\r\n                return data;\r\n            }\r\n            else {\r\n                // something went wrong, user data sub does not match that from id_token\r\n                this.loggerService.logWarning(configId, `User data sub does not match sub in id_token, resetting`);\r\n                this.resetUserDataInStore(configId);\r\n                return null;\r\n            }\r\n        }));\r\n    }\r\n    getIdentityUserData(configId) {\r\n        const token = this.storagePersistenceService.getAccessToken(configId);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'init check session: authWellKnownEndpoints is undefined');\r\n            return throwError('authWellKnownEndpoints is undefined');\r\n        }\r\n        const userInfoEndpoint = authWellKnownEndPoints.userinfoEndpoint;\r\n        if (!userInfoEndpoint) {\r\n            this.loggerService.logError(configId, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\r\n            return throwError('authWellKnownEndpoints.userinfo_endpoint is undefined');\r\n        }\r\n        return this.oidcDataService.get(userInfoEndpoint, configId, token).pipe(retry(2));\r\n    }\r\n    validateUserDataSubIdToken(idTokenSub, userDataSub) {\r\n        if (!idTokenSub) {\r\n            return false;\r\n        }\r\n        if (!userDataSub) {\r\n            return false;\r\n        }\r\n        if (idTokenSub !== userDataSub) {\r\n            this.loggerService.logDebug('validateUserDataSubIdToken failed', idTokenSub, userDataSub);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    fireUserDataEvent(configId, passedUserData) {\r\n        const userData = this.composeSingleOrMultipleUserDataObject(configId, passedUserData);\r\n        this.userDataInternal$.next(userData);\r\n        this.eventService.fireEvent(EventTypes.UserDataChanged, { configId, userData: passedUserData });\r\n    }\r\n    composeSingleOrMultipleUserDataObject(configId, passedUserData) {\r\n        const hasManyConfigs = this.configurationProvider.hasManyConfigs();\r\n        if (!hasManyConfigs) {\r\n            return this.composeSingleUserDataResult(configId, passedUserData);\r\n        }\r\n        const configs = this.configurationProvider.getAllConfigurations();\r\n        const allUserData = configs.map((config) => {\r\n            if (this.currentConfigIsToUpdate(configId, config)) {\r\n                return { configId: config.configId, userData: passedUserData };\r\n            }\r\n            const alreadySavedUserData = this.storagePersistenceService.read('userData', config.configId) || null;\r\n            return { configId: config.configId, userData: alreadySavedUserData };\r\n        });\r\n        return {\r\n            userData: null,\r\n            allUserData,\r\n        };\r\n    }\r\n    composeSingleUserDataResult(configId, userData) {\r\n        return {\r\n            userData,\r\n            allUserData: [{ configId, userData }],\r\n        };\r\n    }\r\n    currentConfigIsToUpdate(configId, config) {\r\n        return config.configId === configId;\r\n    }\r\n}\r\nUserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }, { type: ConfigurationProvider }]; } });\n\nclass ResetAuthDataService {\r\n    constructor(authStateService, flowsDataService, userService) {\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n    }\r\n    resetAuthorizationData(configId) {\r\n        this.userService.resetUserDataInStore(configId);\r\n        this.flowsDataService.resetStorageFlowData(configId);\r\n        this.authStateService.setUnauthenticatedAndFireEvent(configId);\r\n    }\r\n}\r\nResetAuthDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResetAuthDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResetAuthDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }]; } });\n\nclass ImplicitFlowCallbackHandlerService {\r\n    constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 1 Code Flow\r\n    // STEP 1 Implicit Flow\r\n    implicitFlowCallback(configId, hash) {\r\n        const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, 'BEGIN callback, no auth data');\r\n        if (!isRenewProcessData) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n        }\r\n        hash = hash || this.doc.location.hash.substr(1);\r\n        const authResult = hash.split('&').reduce((resultData, item) => {\r\n            const parts = item.split('=');\r\n            resultData[parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        const callbackContext = {\r\n            code: null,\r\n            refreshToken: null,\r\n            state: null,\r\n            sessionState: null,\r\n            authResult,\r\n            isRenewProcess: isRenewProcessData,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(callbackContext);\r\n    }\r\n}\r\nImplicitFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\n/* eslint-disable no-shadow */\r\nvar ValidationResult;\r\n(function (ValidationResult) {\r\n    ValidationResult[\"NotSet\"] = \"NotSet\";\r\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\r\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\r\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\r\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\r\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\r\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\r\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\r\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\r\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\r\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\r\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\r\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\r\n    ValidationResult[\"Ok\"] = \"Ok\";\r\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\r\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\r\n})(ValidationResult || (ValidationResult = {}));\n\nclass SigninKeyDataService {\r\n    constructor(storagePersistenceService, loggerService, dataService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n    }\r\n    getSigningKeys(configId) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const jwksUri = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.jwksUri;\r\n        if (!jwksUri) {\r\n            const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\r\n            this.loggerService.logWarning(configId, error);\r\n            return throwError(error);\r\n        }\r\n        this.loggerService.logDebug(configId, 'Getting signinkeys from ', jwksUri);\r\n        return this.dataService.get(jwksUri, configId).pipe(retry(2), catchError((e) => this.handleErrorGetSigningKeys(e, configId)));\r\n    }\r\n    handleErrorGetSigningKeys(errorResponse, configId) {\r\n        let errMsg = '';\r\n        if (errorResponse instanceof HttpResponse) {\r\n            const body = errorResponse.body || {};\r\n            const err = JSON.stringify(body);\r\n            const { status, statusText } = errorResponse;\r\n            errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\r\n        }\r\n        else {\r\n            const { message } = errorResponse;\r\n            errMsg = !!message ? message : `${errorResponse}`;\r\n        }\r\n        this.loggerService.logError(configId, errMsg);\r\n        return throwError(errMsg);\r\n    }\r\n}\r\nSigninKeyDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSigninKeyDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SigninKeyDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });\n\nconst JWT_KEYS = 'jwtKeys';\r\nclass HistoryJwtKeysCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.signInKeyDataService = signInKeyDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\r\n    callbackHistoryAndResetJwtKeys(callbackContext, configId) {\r\n        this.storagePersistenceService.write('authnResult', callbackContext.authResult, configId);\r\n        if (this.historyCleanUpTurnedOn(configId) && !callbackContext.isRenewProcess) {\r\n            this.resetBrowserHistory();\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'history clean up inactive');\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\r\n            this.loggerService.logDebug(configId, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\r\n        return this.signInKeyDataService.getSigningKeys(configId).pipe(tap((jwtKeys) => this.storeSigningKeys(jwtKeys, configId)), catchError((err) => {\r\n            // fallback: try to load jwtKeys from storage\r\n            const storedJwtKeys = this.readSigningKeys(configId);\r\n            if (!!storedJwtKeys) {\r\n                this.loggerService.logWarning(configId, `Failed to retrieve signing keys, fallback to stored keys`);\r\n                return of(storedJwtKeys);\r\n            }\r\n            return throwError(err);\r\n        }), switchMap((jwtKeys) => {\r\n            if (jwtKeys) {\r\n                callbackContext.jwtKeys = jwtKeys;\r\n                return of(callbackContext);\r\n            }\r\n            const errorMessage = `Failed to retrieve signing key`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve signing key with error: ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleResultErrorFromCallback(result, isRenewProcess) {\r\n        let validationResult = ValidationResult.SecureTokenServerError;\r\n        if (result.error === 'login_required') {\r\n            validationResult = ValidationResult.LoginRequired;\r\n        }\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    historyCleanUpTurnedOn(configId) {\r\n        const { historyCleanupOff } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !historyCleanupOff;\r\n    }\r\n    resetBrowserHistory() {\r\n        window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\r\n    }\r\n    storeSigningKeys(jwtKeys, configId) {\r\n        this.storagePersistenceService.write(JWT_KEYS, jwtKeys, configId);\r\n    }\r\n    readSigningKeys(configId) {\r\n        return this.storagePersistenceService.read(JWT_KEYS, configId);\r\n    }\r\n}\r\nHistoryJwtKeysCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHistoryJwtKeysCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }]; } });\n\nclass UserCallbackHandlerService {\r\n    constructor(loggerService, configurationProvider, authStateService, flowsDataService, userService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 5 userData\r\n    callbackUser(callbackContext, configId) {\r\n        const { isRenewProcess, validationResult, authResult, refreshToken } = callbackContext;\r\n        const { autoUserInfo, renewUserInfoAfterTokenRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!autoUserInfo) {\r\n            if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\r\n                // userData is set to the id_token decoded, auto get user data set to false\r\n                if (validationResult.decodedIdToken) {\r\n                    this.userService.setUserDataToStore(validationResult.decodedIdToken, configId);\r\n                }\r\n            }\r\n            if (!isRenewProcess && !refreshToken) {\r\n                this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n            }\r\n            this.publishAuthState(validationResult, isRenewProcess);\r\n            return of(callbackContext);\r\n        }\r\n        return this.userService\r\n            .getAndPersistUserDataInStore(configId, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)\r\n            .pipe(switchMap((userData) => {\r\n            if (!!userData) {\r\n                if (!refreshToken) {\r\n                    this.flowsDataService.setSessionState(authResult.session_state, configId);\r\n                }\r\n                this.publishAuthState(validationResult, isRenewProcess);\r\n                return of(callbackContext);\r\n            }\r\n            else {\r\n                this.resetAuthDataService.resetAuthorizationData(configId);\r\n                this.publishUnauthenticatedState(validationResult, isRenewProcess);\r\n                const errorMessage = `Called for userData but they were ${userData}`;\r\n                this.loggerService.logWarning(configId, errorMessage);\r\n                return throwError(errorMessage);\r\n            }\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve user info with error:  ${err}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    publishAuthState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: true,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nUserCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: UserCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });\n\nclass StateValidationResult {\r\n    constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {}, state = ValidationResult.NotSet) {\r\n        this.accessToken = accessToken;\r\n        this.idToken = idToken;\r\n        this.authResponseIsValid = authResponseIsValid;\r\n        this.decodedIdToken = decodedIdToken;\r\n        this.state = state;\r\n    }\r\n}\n\nclass EqualityService {\r\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\r\n        if (this.isNullOrUndefined(value1)) {\r\n            return false;\r\n        }\r\n        if (this.isNullOrUndefined(value2)) {\r\n            return false;\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysHaveEqualContent(value1, value2);\r\n        }\r\n        return false;\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysStrictEqual(value1, value2);\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n    bothValuesAreObjects(value1, value2) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n    bothValuesAreStrings(value1, value2) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n    bothValuesAreArrays(value1, value2) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n    valueIsString(value) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n    valueIsObject(value) {\r\n        return typeof value === 'object';\r\n    }\r\n    arraysStrictEqual(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = arr1.length; i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    arraysHaveEqualContent(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        return arr1.some((v) => arr2.includes(v));\r\n    }\r\n    isNullOrUndefined(val) {\r\n        return val === null || val === undefined;\r\n    }\r\n}\r\nEqualityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nEqualityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: EqualityService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StateValidationService {\r\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, configurationProvider, equalityService, flowHelper) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.equalityService = equalityService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    getValidatedStateResult(callbackContext, configId) {\r\n        if (!callbackContext) {\r\n            return new StateValidationResult('', '', false, {});\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            return new StateValidationResult('', '', false, {});\r\n        }\r\n        return this.validateState(callbackContext, configId);\r\n    }\r\n    validateState(callbackContext, configId) {\r\n        const toReturn = new StateValidationResult();\r\n        const authStateControl = this.storagePersistenceService.read('authStateControl', configId);\r\n        if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configId)) {\r\n            this.loggerService.logWarning(configId, 'authCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return toReturn;\r\n        }\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configId);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\r\n            toReturn.accessToken = callbackContext.authResult.access_token;\r\n        }\r\n        if (callbackContext.authResult.id_token) {\r\n            const { clientId, issValidationOff, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, ignoreNonceAfterRefresh } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            toReturn.idToken = callbackContext.authResult.id_token;\r\n            toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configId);\r\n            if (!this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configId)) {\r\n                this.loggerService.logDebug(configId, 'authCallback Signature validation failed id_token');\r\n                toReturn.state = ValidationResult.SignatureFailed;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            const authNonce = this.storagePersistenceService.read('authNonce', configId);\r\n            if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect nonce');\r\n                toReturn.state = ValidationResult.IncorrectNonce;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logDebug(configId, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n            if (authWellKnownEndPoints) {\r\n                if (issValidationOff) {\r\n                    this.loggerService.logDebug(configId, 'iss validation is turned off, this is not recommended!');\r\n                }\r\n                else if (!issValidationOff &&\r\n                    !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configId)) {\r\n                    this.loggerService.logWarning(configId, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                    toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                    this.handleUnsuccessfulValidation(configId);\r\n                    return toReturn;\r\n                }\r\n            }\r\n            else {\r\n                this.loggerService.logWarning(configId, 'authWellKnownEndpoints is undefined');\r\n                toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect aud');\r\n                toReturn.state = ValidationResult.IncorrectAud;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\r\n                this.loggerService.logWarning(configId, 'authCallback missing azp');\r\n                toReturn.state = ValidationResult.IncorrectAzp;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect azp');\r\n                toReturn.state = ValidationResult.IncorrectAzp;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback pre, post id_token claims do not match in refresh');\r\n                toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n            if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configId)) {\r\n                this.loggerService.logWarning(configId, 'authCallback id token expired');\r\n                toReturn.state = ValidationResult.TokenExpired;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configId, 'No id_token found, skipping id_token validation');\r\n        }\r\n        // flow id_token\r\n        if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation(configId);\r\n            this.handleUnsuccessfulValidation(configId);\r\n            return toReturn;\r\n        }\r\n        // only do check if id_token returned, no always the case when using refresh tokens\r\n        if (callbackContext.authResult.id_token) {\r\n            const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configId);\r\n            // The at_hash is optional for the code flow\r\n            if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\r\n                this.loggerService.logDebug(configId, 'Code Flow active, and no at_hash in the id_token, skipping check!');\r\n            }\r\n            else if (!this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RSA256'\r\n            configId) ||\r\n                !toReturn.accessToken) {\r\n                this.loggerService.logWarning(configId, 'authCallback incorrect at_hash');\r\n                toReturn.state = ValidationResult.IncorrectAtHash;\r\n                this.handleUnsuccessfulValidation(configId);\r\n                return toReturn;\r\n            }\r\n        }\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation(configId);\r\n        return toReturn;\r\n    }\r\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configId) {\r\n        const { useRefreshToken, disableRefreshIdTokenAuthTimeValidation } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!useRefreshToken) {\r\n            return true;\r\n        }\r\n        if (!callbackContext.existingIdToken) {\r\n            return true;\r\n        }\r\n        const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configId);\r\n        // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\r\n        // except that it might not contain an id_token.\r\n        // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\r\n        // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.iss !== newIdToken.iss) {\r\n            this.loggerService.logDebug(configId, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\r\n            return false;\r\n        }\r\n        // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\r\n        //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\r\n        // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\r\n        if (decodedIdToken.azp !== newIdToken.azp) {\r\n            this.loggerService.logDebug(configId, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\r\n            return false;\r\n        }\r\n        // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.sub !== newIdToken.sub) {\r\n            this.loggerService.logDebug(configId, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\r\n            return false;\r\n        }\r\n        // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud, newIdToken === null || newIdToken === void 0 ? void 0 : newIdToken.aud)) {\r\n            this.loggerService.logDebug(configId, `aud in new id_token is not valid: '${decodedIdToken === null || decodedIdToken === void 0 ? void 0 : decodedIdToken.aud}' '${newIdToken.aud}'`);\r\n            return false;\r\n        }\r\n        if (disableRefreshIdTokenAuthTimeValidation) {\r\n            return true;\r\n        }\r\n        // its iat Claim MUST represent the time that the new ID Token is issued,\r\n        // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\r\n        // - not the time that the new ID token is issued,\r\n        if (decodedIdToken.auth_time !== newIdToken.auth_time) {\r\n            this.loggerService.logDebug(configId, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    handleSuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) validated, continue');\r\n    }\r\n    handleUnsuccessfulValidation(configId) {\r\n        const { autoCleanStateAfterAuthentication } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.storagePersistenceService.write('authNonce', null, configId);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configId);\r\n        }\r\n        this.loggerService.logDebug(configId, 'authCallback token(s) invalid');\r\n    }\r\n}\r\nStateValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: EqualityService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: EqualityService }, { type: FlowHelper }]; } });\n\nclass StateValidationCallbackHandlerService {\r\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\r\n        this.loggerService = loggerService;\r\n        this.stateValidationService = stateValidationService;\r\n        this.authStateService = authStateService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 4 All flows\r\n    callbackStateValidation(callbackContext, configId) {\r\n        const validationResult = this.stateValidationService.getValidatedStateResult(callbackContext, configId);\r\n        callbackContext.validationResult = validationResult;\r\n        if (validationResult.authResponseIsValid) {\r\n            this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configId);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\r\n            this.loggerService.logWarning(configId, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\r\n            return throwError(errorMessage);\r\n        }\r\n    }\r\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nStateValidationCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StateValidationCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass RefreshSessionCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    // STEP 1 Refresh session\r\n    refreshSessionWithRefreshTokens(configId) {\r\n        const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(configId);\r\n        this.loggerService.logDebug(configId, 'RefreshSession created. Adding myautostate: ' + stateData);\r\n        const refreshToken = this.authStateService.getRefreshToken(configId);\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        if (refreshToken) {\r\n            const callbackContext = {\r\n                code: null,\r\n                refreshToken,\r\n                state: stateData,\r\n                sessionState: null,\r\n                authResult: null,\r\n                isRenewProcess: true,\r\n                jwtKeys: null,\r\n                validationResult: null,\r\n                existingIdToken: idToken,\r\n            };\r\n            this.loggerService.logDebug(configId, 'found refresh code, obtaining new credentials with refresh code');\r\n            // Nonce is not used with refresh tokens; but Key cloak may send it anyway\r\n            this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, configId);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = 'no refresh token found, please login';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n    }\r\n}\r\nRefreshSessionCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });\n\nclass RefreshTokenCallbackHandlerService {\r\n    constructor(urlService, loggerService, configurationProvider, dataService, storagePersistenceService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    // STEP 2 Refresh Token\r\n    refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const tokenEndpoint = authWellknownEndpoints === null || authWellknownEndpoints === void 0 ? void 0 : authWellknownEndpoints.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError('Token Endpoint not defined');\r\n        }\r\n        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, configId, customParamsRefresh);\r\n        return this.dataService.post(tokenEndpoint, data, configId, headers).pipe(switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'token refresh response: ', response);\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, configId)), catchError((error) => {\r\n            const { authority } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, configId) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(configId, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nRefreshTokenCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshTokenCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass FlowsService {\r\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\r\n        this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\r\n        this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\r\n        this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\r\n        this.userHandlerService = userHandlerService;\r\n        this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\r\n        this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\r\n        this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\r\n    }\r\n    processCodeFlowCallback(urlToCheck, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, configId).pipe(concatMap((callbackContext) => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, configId)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processSilentRenewCodeFlowCallback(firstContext, configId) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, configId).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processImplicitFlowCallback(configId, hash) {\r\n        return this.implicitFlowCallbackHandlerService.implicitFlowCallback(configId, hash).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n    processRefreshToken(configId, customParamsRefresh) {\r\n        return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(configId).pipe(concatMap((callbackContext) => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, configId, customParamsRefresh)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, configId)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, configId)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, configId)));\r\n    }\r\n}\r\nFlowsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: FlowsService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });\n\nclass IntervalService {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.runTokenValidationRunning = null;\r\n    }\r\n    stopPeriodicTokenCheck() {\r\n        if (this.runTokenValidationRunning) {\r\n            this.runTokenValidationRunning.unsubscribe();\r\n            this.runTokenValidationRunning = null;\r\n        }\r\n    }\r\n    startPeriodicTokenCheck(repeatAfterSeconds) {\r\n        const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\r\n        return new Observable((subscriber) => {\r\n            let intervalId;\r\n            this.zone.runOutsideAngular(() => {\r\n                intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\r\n            });\r\n            return () => {\r\n                clearInterval(intervalId);\r\n            };\r\n        });\r\n    }\r\n}\r\nIntervalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIntervalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IntervalService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass ImplicitFlowCallbackService {\r\n    constructor(flowsService, configurationProvider, router, flowsDataService, intervalService) {\r\n        this.flowsService = flowsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    authenticatedImplicitFlowCallback(configId, hash) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processImplicitFlowCallback(configId, hash).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nImplicitFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: ConfigurationProvider }, { token: i2.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ImplicitFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: ConfigurationProvider }, { type: i2.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });\n\nclass IFrameService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getExistingIFrame(identifier) {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n    addIFrameToWindowBody(identifier, configId) {\r\n        const sessionIframe = this.doc.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        sessionIframe.title = identifier;\r\n        this.loggerService.logDebug(configId, sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        this.doc.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n    getIFrameFromParentWindow(identifier) {\r\n        try {\r\n            const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    getIFrameFromWindow(identifier) {\r\n        const iFrameElement = this.doc.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n    isIFrameElement(element) {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\nIFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: IFrameService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }]; } });\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\nclass CheckSessionService {\r\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, configurationProvider, zone) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.iFrameService = iFrameService;\r\n        this.eventService = eventService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.zone = zone;\r\n        this.checkSessionReceived = false;\r\n        this.lastIFrameRefresh = 0;\r\n        this.outstandingMessages = 0;\r\n        this.heartBeatInterval = 3000;\r\n        this.iframeRefreshInterval = 60000;\r\n        this.checkSessionChangedInternal$ = new BehaviorSubject(false);\r\n    }\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionChangedInternal$.asObservable();\r\n    }\r\n    isCheckSessionConfigured(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession;\r\n    }\r\n    start(configId) {\r\n        if (!!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        const { clientId } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        this.pollServerSession(clientId, configId);\r\n    }\r\n    stop() {\r\n        if (!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        this.clearScheduledHeartBeat();\r\n        this.checkSessionReceived = false;\r\n    }\r\n    serverStateChanged(configId) {\r\n        const { startCheckSession } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return startCheckSession && this.checkSessionReceived;\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n    }\r\n    init(configId) {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return of(undefined);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return of();\r\n        }\r\n        const existingIframe = this.getOrCreateIframe(configId);\r\n        const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\r\n        if (checkSessionIframe) {\r\n            existingIframe.contentWindow.location.replace(checkSessionIframe);\r\n        }\r\n        else {\r\n            this.loggerService.logWarning(configId, 'CheckSession - init check session: checkSessionIframe is not configured to run');\r\n        }\r\n        return new Observable((observer) => {\r\n            existingIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next();\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n    pollServerSession(clientId, configId) {\r\n        this.outstandingMessages = 0;\r\n        const pollServerSessionRecur = () => {\r\n            this.init(configId)\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                var _a;\r\n                const existingIframe = this.getExistingIframe();\r\n                if (existingIframe && clientId) {\r\n                    this.loggerService.logDebug(configId, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                    const sessionState = this.storagePersistenceService.read('session_state', configId);\r\n                    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n                    if (sessionState && (authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe)) {\r\n                        const iframeOrigin = (_a = new URL(authWellKnownEndPoints.checkSessionIframe)) === null || _a === void 0 ? void 0 : _a.origin;\r\n                        this.outstandingMessages++;\r\n                        existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\r\n                    }\r\n                    else {\r\n                        this.loggerService.logDebug(configId, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\r\n                        this.checkSessionChangedInternal$.next(true);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configId, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                }\r\n                // after sending three messages with no response, fail.\r\n                if (this.outstandingMessages > 3) {\r\n                    this.loggerService.logError(configId, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\r\n                }\r\n                this.zone.runOutsideAngular(() => {\r\n                    this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\r\n                });\r\n            });\r\n        };\r\n        pollServerSessionRecur();\r\n    }\r\n    clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeatRunning);\r\n        this.scheduledHeartBeatRunning = null;\r\n    }\r\n    messageHandler(configId, e) {\r\n        var _a;\r\n        const existingIFrame = this.getExistingIframe();\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        const startsWith = !!((_a = authWellKnownEndPoints === null || authWellKnownEndPoints === void 0 ? void 0 : authWellKnownEndPoints.checkSessionIframe) === null || _a === void 0 ? void 0 : _a.startsWith(e.origin));\r\n        this.outstandingMessages = 0;\r\n        if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning(configId, 'CheckSession - error from check session messageHandler');\r\n            }\r\n            else if (e.data === 'changed') {\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e} from check session messageHandler`);\r\n                this.checkSessionReceived = true;\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.checkSessionChangedInternal$.next(true);\r\n            }\r\n            else {\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.loggerService.logDebug(configId, `CheckSession - ${e.data} from check session messageHandler`);\r\n            }\r\n        }\r\n    }\r\n    bindMessageEventToIframe(configId) {\r\n        const iframeMessageEvent = this.messageHandler.bind(this, configId);\r\n        window.addEventListener('message', iframeMessageEvent, false);\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configId);\r\n            this.bindMessageEventToIframe(configId);\r\n            return frame;\r\n        }\r\n        return existingIframe;\r\n    }\r\n}\r\nCheckSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckSessionService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: i0.NgZone }]; } });\n\nclass CurrentUrlService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getStateParamFromCurrentUrl() {\r\n        const currentUrl = this.getCurrentUrl();\r\n        const parsedUrl = new URL(currentUrl);\r\n        const urlParams = new URLSearchParams(parsedUrl.search);\r\n        const stateFromUrl = urlParams.get('state');\r\n        return stateFromUrl;\r\n    }\r\n    currentUrlHasStateParam() {\r\n        return !!this.getStateParamFromCurrentUrl();\r\n    }\r\n    getCurrentUrl() {\r\n        return this.doc.defaultView.location.toString();\r\n    }\r\n}\r\nCurrentUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCurrentUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CurrentUrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\nclass SilentRenewService {\r\n    constructor(configurationProvider, iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.iFrameService = iFrameService;\r\n        this.flowsService = flowsService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.authStateService = authStateService;\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.intervalService = intervalService;\r\n        this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\r\n    }\r\n    get refreshSessionWithIFrameCompleted$() {\r\n        return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\r\n    }\r\n    getOrCreateIframe(configId) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, configId);\r\n        }\r\n        return existingIframe;\r\n    }\r\n    isSilentRenewConfigured(configId) {\r\n        const { useRefreshToken, silentRenew } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return !useRefreshToken && silentRenew;\r\n    }\r\n    codeFlowCallbackSilentRenewIframe(urlParts, configId) {\r\n        const params = new HttpParams({\r\n            fromString: urlParts[1],\r\n        });\r\n        const error = params.get('error');\r\n        if (error) {\r\n            this.authStateService.updateAndPublishAuthState({\r\n                isAuthenticated: false,\r\n                validationResult: ValidationResult.LoginRequired,\r\n                isRenewProcess: true,\r\n            });\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            this.flowsDataService.setNonce('', configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            return throwError(error);\r\n        }\r\n        const code = params.get('code');\r\n        const state = params.get('state');\r\n        const sessionState = params.get('session_state');\r\n        const callbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: true,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, configId).pipe(catchError((errorFromFlow) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(errorFromFlow);\r\n        }));\r\n    }\r\n    silentRenewEventHandler(e, configId) {\r\n        this.loggerService.logDebug(configId, 'silentRenewEventHandler');\r\n        if (!e.detail) {\r\n            return;\r\n        }\r\n        let callback$ = of(null);\r\n        const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configId);\r\n        if (isCodeFlow) {\r\n            const urlParts = e.detail.toString().split('?');\r\n            callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, configId);\r\n        }\r\n        else {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId, e.detail);\r\n        }\r\n        callback$.subscribe((callbackContext) => {\r\n            this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n        }, (err) => {\r\n            this.loggerService.logError(configId, 'Error: ' + err);\r\n            this.refreshSessionWithIFrameCompletedInternal$.next(null);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n        });\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n    }\r\n}\r\nSilentRenewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService, deps: [{ token: ConfigurationProvider }, { token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSilentRenewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: SilentRenewService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });\n\nclass CodeFlowCallbackService {\r\n    constructor(flowsService, flowsDataService, intervalService, configurationProvider, router) {\r\n        this.flowsService = flowsService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.router = router;\r\n    }\r\n    authenticatedCallbackWithCode(urlToCheck, configId) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.flowsService.processCodeFlowCallback(urlToCheck, configId).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: ConfigurationProvider }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CodeFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: ConfigurationProvider }, { type: i2.Router }]; } });\n\nclass CallbackService {\r\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\r\n        this.urlService = urlService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.codeFlowCallbackService = codeFlowCallbackService;\r\n        this.stsCallbackInternal$ = new Subject();\r\n    }\r\n    get stsCallback$() {\r\n        return this.stsCallbackInternal$.asObservable();\r\n    }\r\n    isCallback(currentUrl) {\r\n        return this.urlService.isCallbackFromSts(currentUrl);\r\n    }\r\n    handleCallbackAndFireEvents(currentCallbackUrl, configId) {\r\n        let callback$;\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, configId);\r\n        }\r\n        else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(configId);\r\n        }\r\n        return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\r\n    }\r\n}\r\nCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\r\nclass AuthWellKnownDataService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpoint, configId) {\r\n        return this.getWellKnownDocument(authWellknownEndpoint, configId).pipe(map((wellKnownEndpoints) => ({\r\n            issuer: wellKnownEndpoints.issuer,\r\n            jwksUri: wellKnownEndpoints.jwks_uri,\r\n            authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\r\n            tokenEndpoint: wellKnownEndpoints.token_endpoint,\r\n            userinfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\r\n            endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\r\n            checkSessionIframe: wellKnownEndpoints.check_session_iframe,\r\n            revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\r\n            introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\r\n            parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,\r\n        })));\r\n    }\r\n    getWellKnownDocument(wellKnownEndpoint, configId) {\r\n        let url = wellKnownEndpoint;\r\n        if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\r\n            url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\r\n        }\r\n        return this.http.get(url, configId).pipe(retry(2));\r\n    }\r\n}\r\nAuthWellKnownDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService, deps: [{ token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }]; } });\n\nclass AuthWellKnownService {\r\n    constructor(publicEventsService, dataService, storagePersistenceService) {\r\n        this.publicEventsService = publicEventsService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId) {\r\n        const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!!alreadySavedWellKnownEndpoints) {\r\n            return of(alreadySavedWellKnownEndpoints);\r\n        }\r\n        return this.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId).pipe(tap((mappedWellKnownEndpoints) => this.storeWellKnownEndpoints(configId, mappedWellKnownEndpoints)), catchError((error) => {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\r\n            return throwError(error);\r\n        }));\r\n    }\r\n    storeWellKnownEndpoints(configId, mappedWellKnownEndpoints) {\r\n        this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, configId);\r\n    }\r\n    getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId) {\r\n        return this.dataService.getWellKnownEndPointsFromUrl(authWellknownEndpointUrl, configId);\r\n    }\r\n}\r\nAuthWellKnownService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService, deps: [{ token: PublicEventsService }, { token: AuthWellKnownDataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthWellKnownService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: PublicEventsService }, { type: AuthWellKnownDataService }, { type: StoragePersistenceService }]; } });\n\nclass RefreshSessionIframeService {\r\n    constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.renderer = rendererFactory.createRenderer(null, null);\r\n    }\r\n    refreshSessionWithIframe(configId, customParams) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize Iframe renew');\r\n        const url = this.urlService.getRefreshSessionSilentRenewUrl(configId, customParams);\r\n        return this.sendAuthorizeRequestUsingSilentRenew(url, configId);\r\n    }\r\n    sendAuthorizeRequestUsingSilentRenew(url, configId) {\r\n        const sessionIframe = this.silentRenewService.getOrCreateIframe(configId);\r\n        this.initSilentRenewRequest(configId);\r\n        this.loggerService.logDebug(configId, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\r\n        return new Observable((observer) => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                this.loggerService.logDebug(configId, 'removed event listener from IFrame');\r\n                observer.next(true);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.contentWindow.location.replace(url);\r\n        });\r\n    }\r\n    initSilentRenewRequest(configId) {\r\n        const instanceId = Math.random();\r\n        const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', (e) => {\r\n            if (e.detail !== instanceId) {\r\n                initDestroyHandler();\r\n                renewDestroyHandler();\r\n            }\r\n        });\r\n        const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', (e) => this.silentRenewService.silentRenewEventHandler(e, configId));\r\n        this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\r\n            detail: instanceId,\r\n        }));\r\n    }\r\n}\r\nRefreshSessionIframeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionIframeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionIframeService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0.RendererFactory2 }]; } });\n\nclass RefreshSessionRefreshTokenService {\r\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\r\n        this.loggerService = loggerService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsService = flowsService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    refreshSessionWithRefreshTokens(configId, customParamsRefresh) {\r\n        this.loggerService.logDebug(configId, 'BEGIN refresh session Authorize');\r\n        return this.flowsService.processRefreshToken(configId, customParamsRefresh).pipe(catchError((error) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return throwError(error);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionRefreshTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionRefreshTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionRefreshTokenService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });\n\nconst MAX_RETRY_ATTEMPTS = 3;\r\nclass RefreshSessionService {\r\n    constructor(flowHelper, configurationProvider, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.authStateService = authStateService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.userService = userService;\r\n    }\r\n    userForceRefreshSession(configId, extraCustomParams) {\r\n        this.persistCustomParams(extraCustomParams, configId);\r\n        return this.forceRefreshSession(configId, extraCustomParams);\r\n    }\r\n    forceRefreshSession(configId, extraCustomParams) {\r\n        const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), extraCustomParams);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            return this.startRefreshSession(configId, mergedParams).pipe(map(() => {\r\n                const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n                if (isAuthenticated) {\r\n                    return {\r\n                        idToken: this.authStateService.getIdToken(configId),\r\n                        accessToken: this.authStateService.getAccessToken(configId),\r\n                        userData: this.userService.getUserDataFromStore(configId),\r\n                        isAuthenticated,\r\n                        configId,\r\n                    };\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        const timeOutTime = silentRenewTimeoutInSeconds * 1000;\r\n        return forkJoin([\r\n            this.startRefreshSession(configId, extraCustomParams),\r\n            this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1)),\r\n        ]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\r\n            var _a, _b;\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                return {\r\n                    idToken: (_a = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _a === void 0 ? void 0 : _a.id_token,\r\n                    accessToken: (_b = callbackContext === null || callbackContext === void 0 ? void 0 : callbackContext.authResult) === null || _b === void 0 ? void 0 : _b.access_token,\r\n                    userData: this.userService.getUserDataFromStore(configId),\r\n                    isAuthenticated,\r\n                    configId,\r\n                };\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    persistCustomParams(extraCustomParams, configId) {\r\n        const { useRefreshToken } = this.configurationProvider.getOpenIDConfiguration();\r\n        if (extraCustomParams) {\r\n            if (useRefreshToken) {\r\n                this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, configId);\r\n            }\r\n            else {\r\n                this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, configId);\r\n            }\r\n        }\r\n    }\r\n    startRefreshSession(configId, extraCustomParams) {\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\r\n        const shouldBeExecuted = !isSilentRenewRunning;\r\n        if (!shouldBeExecuted) {\r\n            return of(null);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId) || {};\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellKnownEndpoint given!');\r\n            return of(null);\r\n        }\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            this.flowsDataService.setSilentRenewRunning(configId);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, extraCustomParams);\r\n            }\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(configId, extraCustomParams);\r\n        }));\r\n    }\r\n    timeoutRetryStrategy(errorAttempts, configId) {\r\n        return errorAttempts.pipe(mergeMap((error, index) => {\r\n            const scalingDuration = 1000;\r\n            const currentAttempt = index + 1;\r\n            if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\r\n                return throwError(error);\r\n            }\r\n            this.loggerService.logDebug(configId, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return timer(currentAttempt * scalingDuration);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RefreshSessionService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });\n\nclass PeriodicallyTokenCheckService {\r\n    constructor(resetAuthDataService, flowHelper, configurationProvider, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.configurationProvider = configurationProvider;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.userService = userService;\r\n        this.authStateService = authStateService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.intervalService = intervalService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n    }\r\n    startTokenValidationPeriodically() {\r\n        const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled();\r\n        if (configsWithSilentRenewEnabled.length <= 0) {\r\n            return;\r\n        }\r\n        const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\r\n        if (!!this.intervalService.runTokenValidationRunning) {\r\n            return;\r\n        }\r\n        // START PERIODICALLY CHECK ONCE AND CHECK EACH CONFIG WHICH HAS IT ENABLED\r\n        const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\r\n            const objectWithConfigIdsAndRefreshEvent = {};\r\n            configsWithSilentRenewEnabled.forEach(({ configId }) => {\r\n                objectWithConfigIdsAndRefreshEvent[configId] = this.getRefreshEvent(configId);\r\n            });\r\n            return forkJoin(objectWithConfigIdsAndRefreshEvent);\r\n        }));\r\n        this.intervalService.runTokenValidationRunning = periodicallyCheck$.subscribe((objectWithConfigIds) => {\r\n            for (const [key, _] of Object.entries(objectWithConfigIds)) {\r\n                this.loggerService.logDebug(key, 'silent renew, periodic check finished!');\r\n                if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(key)) {\r\n                    this.flowsDataService.resetSilentRenewRunning(key);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getRefreshEvent(configId) {\r\n        const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(configId);\r\n        if (!shouldStartRefreshEvent) {\r\n            return of(null);\r\n        }\r\n        const refreshEvent$ = this.createRefreshEventForConfig(configId);\r\n        this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\r\n        const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError((error) => {\r\n            this.loggerService.logError(configId, 'silent renew failed!', error);\r\n            this.flowsDataService.resetSilentRenewRunning(configId);\r\n            return throwError(error);\r\n        }));\r\n        return refreshEventWithErrorHandler$;\r\n    }\r\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\r\n        const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\r\n        return result.tokenRefreshInSeconds;\r\n    }\r\n    getConfigsWithSilentRenewEnabled() {\r\n        return this.configurationProvider.getAllConfigurations().filter((x) => x.silentRenew);\r\n    }\r\n    createRefreshEventForConfig(configId) {\r\n        this.loggerService.logDebug(configId, 'starting silent renew...');\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!(config === null || config === void 0 ? void 0 : config.silentRenew)) {\r\n            this.resetAuthDataService.resetAuthorizationData(configId);\r\n            return of(null);\r\n        }\r\n        this.flowsDataService.setSilentRenewRunning(configId);\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(configId)) {\r\n            // Retrieve Dynamically Set Custom Params for refresh body\r\n            const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', configId) || {};\r\n            const { customParamsRefreshTokenRequest } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n            const mergedParams = Object.assign(Object.assign({}, customParamsRefreshTokenRequest), customParamsRefresh);\r\n            // Refresh Session using Refresh tokens\r\n            return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(configId, mergedParams);\r\n        }\r\n        // Retrieve Dynamically Set Custom Params\r\n        const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', configId);\r\n        return this.refreshSessionIframeService.refreshSessionWithIframe(configId, customParams);\r\n    }\r\n    shouldStartPeriodicallyCheckForConfig(configId) {\r\n        const idToken = this.authStateService.getIdToken(configId);\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(configId);\r\n        const userDataFromStore = this.userService.getUserDataFromStore(configId);\r\n        this.loggerService.logDebug(configId, `Checking: silentRenewRunning: ${isSilentRenewRunning} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\r\n        const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken;\r\n        if (!shouldBeExecuted) {\r\n            return false;\r\n        }\r\n        const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(configId);\r\n        const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(configId);\r\n        if (!idTokenStillValid && !accessTokenHasExpired) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nPeriodicallyTokenCheckService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: ConfigurationProvider }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPeriodicallyTokenCheckService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PeriodicallyTokenCheckService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: ConfigurationProvider }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });\n\nclass PopUpService {\r\n    constructor() {\r\n        this.STORAGE_IDENTIFIER = 'popupauth';\r\n        this.resultInternal$ = new Subject();\r\n    }\r\n    get result$() {\r\n        return this.resultInternal$.asObservable();\r\n    }\r\n    isCurrentlyInPopup() {\r\n        if (this.canAccessSessionStorage()) {\r\n            const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\r\n            return !!window.opener && window.opener !== window && !!popup;\r\n        }\r\n        return false;\r\n    }\r\n    openPopUp(url, popupOptions) {\r\n        const optionsToPass = this.getOptions(popupOptions);\r\n        this.popUp = window.open(url, '_blank', optionsToPass);\r\n        this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\r\n        const listener = (event) => {\r\n            if (!(event === null || event === void 0 ? void 0 : event.data) || typeof event.data !== 'string') {\r\n                return;\r\n            }\r\n            this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });\r\n            this.cleanUp(listener);\r\n        };\r\n        window.addEventListener('message', listener, false);\r\n        this.handle = window.setInterval(() => {\r\n            if (this.popUp.closed) {\r\n                this.resultInternal$.next({ userClosed: true });\r\n                this.cleanUp(listener);\r\n            }\r\n        }, 200);\r\n    }\r\n    sendMessageToMainWindow(url) {\r\n        if (window.opener) {\r\n            this.sendMessage(url, window.location.href);\r\n        }\r\n    }\r\n    cleanUp(listener) {\r\n        var _a;\r\n        window.removeEventListener('message', listener, false);\r\n        window.clearInterval(this.handle);\r\n        if (this.popUp) {\r\n            (_a = this.popUp.sessionStorage) === null || _a === void 0 ? void 0 : _a.removeItem(this.STORAGE_IDENTIFIER);\r\n            this.popUp.close();\r\n            this.popUp = null;\r\n        }\r\n    }\r\n    sendMessage(url, href) {\r\n        window.opener.postMessage(url, href);\r\n    }\r\n    getOptions(popupOptions) {\r\n        const popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };\r\n        const options = Object.assign(Object.assign({}, popupDefaultOptions), (popupOptions || {}));\r\n        return Object.entries(options)\r\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\r\n            .join(',');\r\n    }\r\n    canAccessSessionStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nPopUpService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\n\nclass CheckAuthService {\r\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, configurationProvider, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.currentUrlService = currentUrlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.callbackService = callbackService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.periodicallyTokenCheckService = periodicallyTokenCheckService;\r\n        this.popupService = popupService;\r\n        this.autoLoginService = autoLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    checkAuth(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for state ${stateParamFromUrl}`);\r\n            }\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            return this.checkAuthWithConfig(config, url);\r\n        }\r\n        const onlyExistingConfig = this.configurationProvider.getOpenIDConfiguration();\r\n        return this.checkAuthWithConfig(onlyExistingConfig, url);\r\n    }\r\n    checkAuthMultiple(passedConfigId, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for state ${stateParamFromUrl}`);\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        if (!!passedConfigId) {\r\n            const config = this.configurationProvider.getOpenIDConfiguration(passedConfigId);\r\n            if (!config) {\r\n                return throwError(`could not find matching config for id ${passedConfigId}`);\r\n            }\r\n            return this.composeMultipleLoginResults(config, url);\r\n        }\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        const allChecks$ = allConfigs.map((x) => this.checkAuthWithConfig(x, url));\r\n        return forkJoin(allChecks$);\r\n    }\r\n    checkAuthIncludingServer(configId) {\r\n        const config = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        return this.checkAuthWithConfig(config).pipe(switchMap((loginResponse) => {\r\n            const { isAuthenticated } = loginResponse;\r\n            if (isAuthenticated) {\r\n                return of(loginResponse);\r\n            }\r\n            return this.refreshSessionService.forceRefreshSession(configId).pipe(tap((loginResponseAfterRefreshSession) => {\r\n                if (loginResponseAfterRefreshSession === null || loginResponseAfterRefreshSession === void 0 ? void 0 : loginResponseAfterRefreshSession.isAuthenticated) {\r\n                    this.startCheckSessionAndValidation(configId);\r\n                }\r\n            }));\r\n        }));\r\n    }\r\n    checkAuthWithConfig(config, url) {\r\n        const { configId, authority } = config;\r\n        if (!this.configurationProvider.hasAsLeastOneConfig()) {\r\n            const errorMessage = 'Please provide at least one configuration before setting up the module';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId });\r\n        }\r\n        const currentUrl = url || this.currentUrlService.getCurrentUrl();\r\n        this.loggerService.logDebug(configId, `Working with config '${configId}' using ${authority}`);\r\n        if (this.popupService.isCurrentlyInPopup()) {\r\n            this.popupService.sendMessageToMainWindow(currentUrl);\r\n            return of(null);\r\n        }\r\n        const isCallback = this.callbackService.isCallback(currentUrl);\r\n        this.loggerService.logDebug(configId, 'currentUrl to check auth with: ', currentUrl);\r\n        const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, configId) : of(null);\r\n        return callback$.pipe(map(() => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n            if (isAuthenticated) {\r\n                this.startCheckSessionAndValidation(configId);\r\n                if (!isCallback) {\r\n                    this.authStateService.setAuthenticatedAndFireEvent();\r\n                    this.userService.publishUserDataIfExists(configId);\r\n                }\r\n            }\r\n            this.loggerService.logDebug(configId, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\r\n            return {\r\n                isAuthenticated,\r\n                userData: this.userService.getUserDataFromStore(configId),\r\n                accessToken: this.authStateService.getAccessToken(configId),\r\n                idToken: this.authStateService.getIdToken(configId),\r\n                configId,\r\n            };\r\n        }), tap(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n        }), catchError((errorMessage) => {\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId });\r\n        }));\r\n    }\r\n    startCheckSessionAndValidation(configId) {\r\n        if (this.checkSessionService.isCheckSessionConfigured(configId)) {\r\n            this.checkSessionService.start(configId);\r\n        }\r\n        this.periodicallyTokenCheckService.startTokenValidationPeriodically();\r\n        if (this.silentRenewService.isSilentRenewConfigured(configId)) {\r\n            this.silentRenewService.getOrCreateIframe(configId);\r\n        }\r\n    }\r\n    getConfigurationWithUrlState(stateFromUrl) {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        for (const config of allConfigs) {\r\n            const storedState = this.storagePersistenceService.read('authStateControl', config.configId);\r\n            if (storedState === stateFromUrl) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    composeMultipleLoginResults(activeConfig, url) {\r\n        const allOtherConfigs = this.configurationProvider.getAllConfigurations().filter((x) => x.configId !== activeConfig.configId);\r\n        const currentConfigResult = this.checkAuthWithConfig(activeConfig, url);\r\n        const allOtherConfigResults = allOtherConfigs.map((config) => {\r\n            const { redirectUrl } = config;\r\n            return this.checkAuthWithConfig(config, redirectUrl);\r\n        });\r\n        return forkJoin([currentConfigResult, ...allOtherConfigResults]);\r\n    }\r\n}\r\nCheckAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: CheckAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }]; } });\n\nconst DEFAULT_CONFIG = {\r\n    authority: 'https://please_set',\r\n    authWellknownEndpointUrl: '',\r\n    authWellknownEndpoints: null,\r\n    redirectUrl: 'https://please_set',\r\n    clientId: 'please_set',\r\n    responseType: 'code',\r\n    scope: 'openid email profile',\r\n    hdParam: '',\r\n    postLogoutRedirectUri: 'https://please_set',\r\n    startCheckSession: false,\r\n    silentRenew: false,\r\n    silentRenewUrl: 'https://please_set',\r\n    silentRenewTimeoutInSeconds: 20,\r\n    renewTimeBeforeTokenExpiresInSeconds: 0,\r\n    useRefreshToken: false,\r\n    usePushedAuthorisationRequests: false,\r\n    ignoreNonceAfterRefresh: false,\r\n    postLoginRoute: '/',\r\n    forbiddenRoute: '/forbidden',\r\n    unauthorizedRoute: '/unauthorized',\r\n    autoUserInfo: true,\r\n    autoCleanStateAfterAuthentication: true,\r\n    triggerAuthorizationResultEvent: false,\r\n    logLevel: LogLevel.Warn,\r\n    issValidationOff: false,\r\n    historyCleanupOff: false,\r\n    maxIdTokenIatOffsetAllowedInSeconds: 120,\r\n    disableIatOffsetValidation: false,\r\n    storage: typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined' ? sessionStorage : null,\r\n    customParamsAuthRequest: {},\r\n    customParamsRefreshTokenRequest: {},\r\n    customParamsEndSessionRequest: {},\r\n    customParamsCodeRequest: {},\r\n    eagerLoadAuthWellKnownEndpoints: true,\r\n    disableRefreshIdTokenAuthTimeValidation: false,\r\n    enableIdTokenExpiredValidationInRenew: true,\r\n    tokenRefreshInSeconds: 4,\r\n    refreshTokenRetryInSeconds: 3,\r\n    ngswBypass: false,\r\n};\n\nconst POSITIVE_VALIDATION_RESULT = {\r\n    result: true,\r\n    messages: [],\r\n    level: null,\r\n};\n\nconst ensureAuthority = (passedConfig) => {\r\n    if (!passedConfig.authority) {\r\n        return {\r\n            result: false,\r\n            messages: ['The authority URL MUST be provided in the configuration! '],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureClientId = (passedConfig) => {\r\n    if (!passedConfig.clientId) {\r\n        return {\r\n            result: false,\r\n            messages: ['The clientId is required and missing from your config!'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst createIdentifierToCheck = (passedConfig) => {\r\n    const { authority, clientId, scope } = passedConfig;\r\n    return `${authority}${clientId}${scope}`;\r\n};\r\nconst arrayHasDuplicates = (array) => new Set(array).size !== array.length;\r\nconst ensureNoDuplicatedConfigsRule = (passedConfigs) => {\r\n    const allIdentifiers = passedConfigs.map((x) => createIdentifierToCheck(x));\r\n    const hasDuplicates = arrayHasDuplicates(allIdentifiers);\r\n    if (hasDuplicates) {\r\n        return {\r\n            result: false,\r\n            messages: ['You added multiple configs with the same authority, clientId and scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureRedirectRule = (passedConfig) => {\r\n    if (!passedConfig.redirectUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['The redirectURL is required and missing from your config'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = (passedConfig) => {\r\n    const usesSilentRenew = passedConfig.silentRenew;\r\n    const usesRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenewUrl = passedConfig.silentRenewUrl;\r\n    if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst useOfflineScopeWithSilentRenew = (passedConfig) => {\r\n    const hasRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenew = passedConfig.silentRenew;\r\n    const scope = passedConfig.scope || '';\r\n    const hasOfflineScope = scope.split(' ').includes('offline_access');\r\n    if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\r\n        return {\r\n            result: false,\r\n            messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst allRules = [\r\n    ensureAuthority,\r\n    useOfflineScopeWithSilentRenew,\r\n    ensureRedirectRule,\r\n    ensureClientId,\r\n    ensureSilentRenewUrlWhenNoRefreshTokenUsed,\r\n];\r\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    validateConfigs(passedConfigs) {\r\n        return this.validateConfigsInternal(passedConfigs, allMultipleConfigRules);\r\n    }\r\n    validateConfig(passedConfig) {\r\n        return this.validateConfigInternal(passedConfig, allRules);\r\n    }\r\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfigs));\r\n        let overallErrorCount = 0;\r\n        passedConfigs.forEach((passedConfig) => {\r\n            const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\r\n            overallErrorCount += errorCount;\r\n        });\r\n        return overallErrorCount === 0;\r\n    }\r\n    validateConfigInternal(passedConfig, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfig));\r\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig.configId);\r\n        return errorCount === 0;\r\n    }\r\n    processValidationResultsAndGetErrorCount(allValidationResults, configId) {\r\n        const allMessages = allValidationResults.filter((x) => x.messages.length > 0);\r\n        const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\r\n        const allWarnings = this.getAllMessagesOfType('warning', allMessages);\r\n        allErrorMessages.forEach((message) => this.loggerService.logError(configId, message));\r\n        allWarnings.forEach((message) => this.loggerService.logWarning(configId, message));\r\n        return allErrorMessages.length;\r\n    }\r\n    getAllMessagesOfType(type, results) {\r\n        const allMessages = results.filter((x) => x.level === type).map((result) => result.messages);\r\n        return allMessages.reduce((acc, val) => acc.concat(val), []);\r\n    }\r\n}\r\nConfigValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ConfigValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass PlatformProvider {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n    }\r\n    get isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n}\r\nPlatformProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPlatformProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PlatformProvider, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass OidcConfigService {\r\n    constructor(loggerService, publicEventsService, configurationProvider, authWellKnownService, storagePersistenceService, configValidationService, platformProvider) {\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.configValidationService = configValidationService;\r\n        this.platformProvider = platformProvider;\r\n    }\r\n    withConfigs(passedConfigs) {\r\n        if (!this.configValidationService.validateConfigs(passedConfigs)) {\r\n            return Promise.resolve(null);\r\n        }\r\n        this.createUniqueIds(passedConfigs);\r\n        const allHandleConfigPromises = passedConfigs.map((x) => this.handleConfig(x));\r\n        return Promise.all(allHandleConfigPromises);\r\n    }\r\n    createUniqueIds(passedConfigs) {\r\n        passedConfigs.forEach((config, index) => {\r\n            if (!config.configId) {\r\n                config.configId = `${index}-${config.clientId}`;\r\n            }\r\n        });\r\n    }\r\n    handleConfig(passedConfig) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!this.configValidationService.validateConfig(passedConfig)) {\r\n                this.loggerService.logError(passedConfig.configId, 'Validation of config rejected with errors. Config is NOT set.');\r\n                resolve(null);\r\n                return;\r\n            }\r\n            if (!passedConfig.authWellknownEndpointUrl) {\r\n                passedConfig.authWellknownEndpointUrl = passedConfig.authority;\r\n            }\r\n            const usedConfig = this.prepareConfig(passedConfig);\r\n            this.configurationProvider.setConfig(usedConfig);\r\n            const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', usedConfig.configId);\r\n            if (!!alreadyExistingAuthWellKnownEndpoints) {\r\n                usedConfig.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n                return;\r\n            }\r\n            const passedAuthWellKnownEndpoints = usedConfig.authWellknownEndpoints;\r\n            if (!!passedAuthWellKnownEndpoints) {\r\n                this.authWellKnownService.storeWellKnownEndpoints(usedConfig.configId, passedAuthWellKnownEndpoints);\r\n                usedConfig.authWellknownEndpoints = passedAuthWellKnownEndpoints;\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n                return;\r\n            }\r\n            if (usedConfig.eagerLoadAuthWellKnownEndpoints) {\r\n                this.authWellKnownService\r\n                    .getAuthWellKnownEndPoints(usedConfig.authWellknownEndpointUrl, usedConfig.configId)\r\n                    .pipe(catchError((error) => {\r\n                    this.loggerService.logError(usedConfig.configId, 'Getting auth well known endpoints failed on start', error);\r\n                    return throwError(error);\r\n                }), tap((wellknownEndPoints) => {\r\n                    usedConfig.authWellknownEndpoints = wellknownEndPoints;\r\n                    this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                }))\r\n                    .subscribe(() => resolve(usedConfig), () => reject());\r\n            }\r\n            else {\r\n                this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, usedConfig);\r\n                resolve(usedConfig);\r\n            }\r\n        });\r\n    }\r\n    prepareConfig(configuration) {\r\n        const openIdConfigurationInternal = Object.assign(Object.assign({}, DEFAULT_CONFIG), configuration);\r\n        this.setSpecialCases(openIdConfigurationInternal);\r\n        return openIdConfigurationInternal;\r\n    }\r\n    setSpecialCases(currentConfig) {\r\n        if (!this.platformProvider.isBrowser) {\r\n            currentConfig.startCheckSession = false;\r\n            currentConfig.silentRenew = false;\r\n            currentConfig.useRefreshToken = false;\r\n            currentConfig.usePushedAuthorisationRequests = false;\r\n        }\r\n    }\r\n}\r\nOidcConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcConfigService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }]; } });\n\nclass OpenIdConfigLoader {\r\n}\r\nclass StsConfigLoader {\r\n}\r\nclass StsConfigStaticLoader {\r\n    constructor(passedConfigs) {\r\n        this.passedConfigs = passedConfigs;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.passedConfigs)) {\r\n            const allInstantStaticPromises = this.passedConfigs.map((x) => new Promise((resolve, _) => resolve(x)));\r\n            return allInstantStaticPromises;\r\n        }\r\n        const singleStaticPromise = new Promise((resolve, _) => resolve(this.passedConfigs));\r\n        return [singleStaticPromise];\r\n    }\r\n}\r\nclass StsConfigHttpLoader {\r\n    constructor(configs$) {\r\n        this.configs$ = configs$;\r\n    }\r\n    loadConfigs() {\r\n        return Array.isArray(this.configs$) ? this.configs$ : [this.configs$];\r\n    }\r\n}\n\nclass ClosestMatchingRouteService {\r\n    constructor(configProvider) {\r\n        this.configProvider = configProvider;\r\n    }\r\n    getConfigIdForClosestMatchingRoute(route) {\r\n        const allConfiguredRoutes = this.getAllConfiguredRoutes();\r\n        for (const routesWithConfig of allConfiguredRoutes) {\r\n            const allRoutesForConfig = routesWithConfig.routes;\r\n            for (const configuredRoute of allRoutesForConfig) {\r\n                if (route.startsWith(configuredRoute)) {\r\n                    return {\r\n                        matchingRoute: configuredRoute,\r\n                        matchingConfigId: routesWithConfig.configId,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            matchingRoute: null,\r\n            matchingConfigId: null,\r\n        };\r\n    }\r\n    getAllConfiguredRoutes() {\r\n        const allConfigurations = this.configProvider.getAllConfigurations();\r\n        return allConfigurations.map((x) => ({ routes: x.secureRoutes, configId: x.configId }));\r\n    }\r\n}\r\nClosestMatchingRouteService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService, deps: [{ token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nClosestMatchingRouteService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ClosestMatchingRouteService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }]; } });\n\nclass ResponseTypeValidationService {\r\n    constructor(loggerService, flowHelper) {\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    hasConfigValidResponseType(configId) {\r\n        if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configId)) {\r\n            return true;\r\n        }\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configId)) {\r\n            return true;\r\n        }\r\n        this.loggerService.logWarning(configId, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\r\n        return false;\r\n    }\r\n}\r\nResponseTypeValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResponseTypeValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ResponseTypeValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });\n\nclass RedirectService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    redirectTo(url) {\r\n        this.doc.location.href = url;\r\n    }\r\n}\r\nRedirectService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRedirectService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: RedirectService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass ParService {\r\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    postParRequest(configId, customParams) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configId);\r\n        if (!authWellknownEndpoints) {\r\n            return throwError('Could not read PAR endpoint because authWellKnownEndPoints are not given');\r\n        }\r\n        const parEndpoint = authWellknownEndpoints.parEndpoint;\r\n        if (!parEndpoint) {\r\n            return throwError('Could not read PAR endpoint from authWellKnownEndpoints');\r\n        }\r\n        const data = this.urlService.createBodyForParCodeFlowRequest(configId, customParams);\r\n        return this.dataService.post(parEndpoint, data, configId, headers).pipe(retry(2), map((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            return {\r\n                expiresIn: response.expires_in,\r\n                requestUri: response.request_uri,\r\n            };\r\n        }), catchError((error) => {\r\n            const errorMessage = `There was an error on ParService postParRequest`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n}\r\nParService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass ParLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService, popupService, checkAuthService, parService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.parService = parService;\r\n    }\r\n    loginPar(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.authWellKnownService\r\n            .getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId)\r\n            .pipe(switchMap(() => this.parService.postParRequest(configId, customParams)))\r\n            .subscribe((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                this.loggerService.logError(configId, `Could not create url with param ${response.requestUri}: '${url}'`);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n    loginWithPopUpPar(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        const { customParams } = authOptions || {};\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => this.parService.postParRequest(configId, customParams)), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configId);\r\n            this.loggerService.logDebug(configId, 'par request url: ', url);\r\n            if (!url) {\r\n                const errorMessage = `Could not create url with param ${response.requestUri}: 'url'`;\r\n                this.loggerService.logError(configId, errorMessage);\r\n                return throwError(errorMessage);\r\n            }\r\n            this.popupService.openPopUp(url, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: ParLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });\n\nclass PopUpLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, configurationProvider, authWellKnownService, popupService, checkAuthService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n    }\r\n    loginWithPopUpStandard(configId, authOptions, popupOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(configId, errorMessage);\r\n            return throwError(errorMessage);\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        return this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).pipe(switchMap(() => {\r\n            const { customParams } = authOptions || {};\r\n            const authUrl = this.urlService.getAuthorizeUrl(configId, customParams);\r\n            this.popupService.openPopUp(authUrl, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configId, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nPopUpLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: PopUpLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });\n\nclass StandardLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, configurationProvider, authWellKnownService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n    }\r\n    loginStandard(configId, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configId)) {\r\n            this.loggerService.logError(configId, 'Invalid response type!');\r\n            return;\r\n        }\r\n        const { authWellknownEndpointUrl } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (!authWellknownEndpointUrl) {\r\n            this.loggerService.logError(configId, 'no authWellknownEndpoint given!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configId, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        this.authWellKnownService.getAuthWellKnownEndPoints(authWellknownEndpointUrl, configId).subscribe(() => {\r\n            const { urlHandler, customParams } = authOptions || {};\r\n            const url = this.urlService.getAuthorizeUrl(configId, customParams);\r\n            if (!url) {\r\n                this.loggerService.logError(configId, 'Could not create url', url);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n}\r\nStandardLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: ConfigurationProvider }, { token: AuthWellKnownService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStandardLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: StandardLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: ConfigurationProvider }, { type: AuthWellKnownService }]; } });\n\nclass LoginService {\r\n    constructor(configurationProvider, parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\r\n        this.configurationProvider = configurationProvider;\r\n        this.parLoginService = parLoginService;\r\n        this.popUpLoginService = popUpLoginService;\r\n        this.standardLoginService = standardLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    login(configId, authOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginPar(configId, authOptions);\r\n        }\r\n        else {\r\n            return this.standardLoginService.loginStandard(configId, authOptions);\r\n        }\r\n    }\r\n    loginWithPopUp(configId, authOptions, popupOptions) {\r\n        if (authOptions === null || authOptions === void 0 ? void 0 : authOptions.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configId);\r\n        }\r\n        const { usePushedAuthorisationRequests } = this.configurationProvider.getOpenIDConfiguration(configId);\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginWithPopUpPar(configId, authOptions, popupOptions);\r\n        }\r\n        else {\r\n            return this.popUpLoginService.loginWithPopUpStandard(configId, authOptions, popupOptions);\r\n        }\r\n    }\r\n}\r\nLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService, deps: [{ token: ConfigurationProvider }, { token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }]; } });\n\nclass LogoffRevocationService {\r\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService, configurationProvider) {\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.checkSessionService = checkSessionService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.redirectService = redirectService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    // Logs out on the server and the local client.\r\n    // If the server state has changed, check session, then only a local logout.\r\n    logoff(configId, authOptions) {\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.loggerService.logDebug(configId, 'logoff, remove auth ');\r\n        const endSessionUrl = this.getEndSessionUrl(configId, customParams);\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        if (!endSessionUrl) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, no end_session_endpoint');\r\n            return;\r\n        }\r\n        if (this.checkSessionService.serverStateChanged(configId)) {\r\n            this.loggerService.logDebug(configId, 'only local login cleaned up, server session has changed');\r\n        }\r\n        else if (urlHandler) {\r\n            urlHandler(endSessionUrl);\r\n        }\r\n        else {\r\n            this.redirectService.redirectTo(endSessionUrl);\r\n        }\r\n    }\r\n    logoffLocal(configId) {\r\n        this.resetAuthDataService.resetAuthorizationData(configId);\r\n        this.checkSessionService.stop();\r\n    }\r\n    logoffLocalMultiple() {\r\n        const allConfigs = this.configurationProvider.getAllConfigurations();\r\n        allConfigs.forEach(({ configId }) => this.logoffLocal(configId));\r\n    }\r\n    // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n    // only the access token is revoked. Then the logout run.\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        const { revocationEndpoint } = this.storagePersistenceService.read('authWellKnownEndPoints', configId) || {};\r\n        if (!revocationEndpoint) {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint not supported');\r\n            this.logoff(configId, authOptions);\r\n        }\r\n        if (this.storagePersistenceService.getRefreshToken(configId)) {\r\n            return this.revokeRefreshToken(configId).pipe(switchMap((result) => this.revokeAccessToken(configId, result)), catchError((error) => {\r\n                const errorMessage = `revoke token failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(errorMessage);\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n        else {\r\n            return this.revokeAccessToken(configId).pipe(catchError((error) => {\r\n                const errorMessage = `revoke accessToken failed`;\r\n                this.loggerService.logError(configId, errorMessage, error);\r\n                return throwError(errorMessage);\r\n            }), tap(() => this.logoff(configId, authOptions)));\r\n        }\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an access token on the STS. If no token is provided, then the token from\r\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\r\n    // manage your own tokens. The is a public API.\r\n    revokeAccessToken(configId, accessToken) {\r\n        const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\r\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n    // This makes it possible to manage your own tokens.\r\n    revokeRefreshToken(configId, refreshToken) {\r\n        const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configId);\r\n        const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configId);\r\n        return this.sendRevokeRequest(configId, body);\r\n    }\r\n    getEndSessionUrl(configId, customParams) {\r\n        const idToken = this.storagePersistenceService.getIdToken(configId);\r\n        const { customParamsEndSessionRequest } = this.configurationProvider.getOpenIDConfiguration();\r\n        const mergedParams = Object.assign(Object.assign({}, customParamsEndSessionRequest), customParams);\r\n        return this.urlService.createEndSessionUrl(idToken, configId, mergedParams);\r\n    }\r\n    sendRevokeRequest(configId, body) {\r\n        const url = this.urlService.getRevocationEndpointUrl(configId);\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return this.dataService.post(url, body, configId, headers).pipe(retry(2), switchMap((response) => {\r\n            this.loggerService.logDebug(configId, 'revocation endpoint post response: ', response);\r\n            return of(response);\r\n        }), catchError((error) => {\r\n            const errorMessage = `Revocation request failed`;\r\n            this.loggerService.logError(configId, errorMessage, error);\r\n            return throwError(errorMessage);\r\n        }));\r\n    }\r\n}\r\nLogoffRevocationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLogoffRevocationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: LogoffRevocationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }, { type: ConfigurationProvider }]; } });\n\nclass OidcSecurityService {\r\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationProvider, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.userService = userService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.callbackService = callbackService;\r\n        this.logoffRevocationService = logoffRevocationService;\r\n        this.loginService = loginService;\r\n        this.refreshSessionService = refreshSessionService;\r\n    }\r\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\r\n    get userData$() {\r\n        return this.userService.userData$;\r\n    }\r\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\r\n    get isAuthenticated$() {\r\n        return this.authStateService.authenticated$;\r\n    }\r\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionService.checkSessionChanged$;\r\n    }\r\n    /**\r\n     * Emits on a secure token server callback. The observable will never contain a value.\r\n     */\r\n    get stsCallback$() {\r\n        return this.callbackService.stsCallback$;\r\n    }\r\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\r\n    getConfigurations() {\r\n        return this.configurationProvider.getAllConfigurations();\r\n    }\r\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\r\n    getConfiguration(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.configurationProvider.getOpenIDConfiguration(configId);\r\n    }\r\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\r\n    getUserData(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration().configId;\r\n        return this.userService.getUserDataFromStore(configId);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The url to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\r\n    checkAuth(url, configId) {\r\n        return this.checkAuthService.checkAuth(configId, url);\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The url to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\r\n    checkAuthMultiple(url, configId) {\r\n        return this.checkAuthService.checkAuthMultiple(configId, url);\r\n    }\r\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\r\n    isAuthenticated(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.isAuthenticated(configId);\r\n    }\r\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\r\n    checkAuthIncludingServer(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.checkAuthService.checkAuthIncludingServer(configId);\r\n    }\r\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\r\n    getAccessToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAccessToken(configId);\r\n    }\r\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\r\n    getIdToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getIdToken(configId);\r\n    }\r\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\r\n    getRefreshToken(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getRefreshToken(configId);\r\n    }\r\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\r\n    getAuthenticationResult(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.authStateService.getAuthenticationResult(configId);\r\n    }\r\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\r\n    getPayloadFromIdToken(encode = false, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        const token = this.authStateService.getIdToken(configId);\r\n        return this.tokenHelperService.getPayloadFromToken(token, encode, configId);\r\n    }\r\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\r\n    setState(state, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.flowsDataService.setAuthStateControl(state, configId);\r\n    }\r\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\r\n    getState(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.flowsDataService.getAuthStateControl(configId);\r\n    }\r\n    /**\r\n     * Redirects the user to the secure token server to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\r\n    authorize(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        this.loginService.login(configId, authOptions);\r\n    }\r\n    /**\r\n     * Opens the secure token server in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.loginService.loginWithPopUp(configId, authOptions, popupOptions);\r\n    }\r\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    forceRefreshSession(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.refreshSessionService.userForceRefreshSession(configId, customParams);\r\n    }\r\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffAndRevokeTokens(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\r\n    logoff(configId, authOptions) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoff(configId, authOptions);\r\n    }\r\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\r\n    logoffLocal(configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.logoffLocal(configId);\r\n    }\r\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\r\n    logoffLocalMultiple() {\r\n        return this.logoffRevocationService.logoffLocalMultiple();\r\n    }\r\n    /**\r\n     * Revokes an access token on the secure token server. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeAccessToken(accessToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeAccessToken(configId, accessToken);\r\n    }\r\n    /**\r\n     * Revokes a refresh token on the secure token server. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeRefreshToken(refreshToken, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.revokeRefreshToken(configId, refreshToken);\r\n    }\r\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\r\n    getEndSessionUrl(customParams, configId) {\r\n        configId = configId !== null && configId !== void 0 ? configId : this.configurationProvider.getOpenIDConfiguration(configId).configId;\r\n        return this.logoffRevocationService.getEndSessionUrl(configId, customParams);\r\n    }\r\n}\r\nOidcSecurityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationProvider }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcSecurityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: OidcSecurityService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationProvider }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }]; } });\n\nclass BrowserStorageService {\r\n    constructor(configProvider, loggerService) {\r\n        this.configProvider = configProvider;\r\n        this.loggerService = loggerService;\r\n    }\r\n    read(key, configId) {\r\n        var _a;\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to read '${key}' but Storage was undefined`);\r\n            return false;\r\n        }\r\n        const item = (_a = this.getStorage(configId)) === null || _a === void 0 ? void 0 : _a.getItem(key);\r\n        if (!item) {\r\n            return null;\r\n        }\r\n        return JSON.parse(item);\r\n    }\r\n    write(key, value, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${key}/${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${key}/${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        value = value || null;\r\n        storage.setItem(`${key}`, JSON.stringify(value));\r\n        return true;\r\n    }\r\n    remove(key, configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to remove '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to write '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.removeItem(`${key}`);\r\n        return true;\r\n    }\r\n    // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\r\n    clear(configId) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        const storage = this.getStorage(configId);\r\n        if (!storage) {\r\n            this.loggerService.logDebug(configId, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        storage.clear();\r\n        return true;\r\n    }\r\n    getStorage(configId) {\r\n        const { storage } = this.configProvider.getOpenIDConfiguration(configId) || {};\r\n        return storage;\r\n    }\r\n    hasStorage() {\r\n        return typeof Storage !== 'undefined';\r\n    }\r\n}\r\nBrowserStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService, deps: [{ token: ConfigurationProvider }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nBrowserStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: BrowserStorageService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ConfigurationProvider }, { type: LoggerService }]; } });\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction createStaticLoader(passedConfig) {\r\n    return new StsConfigStaticLoader(passedConfig.config);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction configurationProviderFactory(oidcConfigService, loader) {\r\n    const allLoadPromises = Promise.all(loader.loadConfigs());\r\n    const fn = () => allLoadPromises.then((configs) => oidcConfigService.withConfigs(configs));\r\n    return fn;\r\n}\r\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\r\nclass AuthModule {\r\n    static forRoot(passedConfig) {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                // Make the PASSED_CONFIG available through injection\r\n                { provide: PASSED_CONFIG, useValue: passedConfig },\r\n                // Create the loader: Either the one getting passed or a static one\r\n                (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.loader) || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },\r\n                // Load the config when the app starts\r\n                {\r\n                    provide: APP_INITIALIZER,\r\n                    multi: true,\r\n                    deps: [OidcConfigService, StsConfigLoader, PASSED_CONFIG],\r\n                    useFactory: configurationProviderFactory,\r\n                },\r\n                {\r\n                    provide: AbstractSecurityStorage,\r\n                    useClass: (passedConfig === null || passedConfig === void 0 ? void 0 : passedConfig.storage) || BrowserStorageService,\r\n                },\r\n                OidcConfigService,\r\n                PublicEventsService,\r\n                FlowHelper,\r\n                ConfigurationProvider,\r\n                OidcSecurityService,\r\n                TokenValidationService,\r\n                PlatformProvider,\r\n                CheckSessionService,\r\n                FlowsDataService,\r\n                FlowsService,\r\n                SilentRenewService,\r\n                LogoffRevocationService,\r\n                UserService,\r\n                RandomService,\r\n                HttpBaseService,\r\n                UrlService,\r\n                AuthStateService,\r\n                SigninKeyDataService,\r\n                StoragePersistenceService,\r\n                TokenHelperService,\r\n                LoggerService,\r\n                IFrameService,\r\n                EqualityService,\r\n                LoginService,\r\n                ParService,\r\n                AuthWellKnownDataService,\r\n                AuthWellKnownService,\r\n                DataService,\r\n                StateValidationService,\r\n                ConfigValidationService,\r\n                CheckAuthService,\r\n                ResetAuthDataService,\r\n                ImplicitFlowCallbackService,\r\n                HistoryJwtKeysCallbackHandlerService,\r\n                ResponseTypeValidationService,\r\n                UserCallbackHandlerService,\r\n                StateValidationCallbackHandlerService,\r\n                RefreshSessionCallbackHandlerService,\r\n                RefreshTokenCallbackHandlerService,\r\n                CodeFlowCallbackHandlerService,\r\n                ImplicitFlowCallbackHandlerService,\r\n                ParLoginService,\r\n                PopUpLoginService,\r\n                StandardLoginService,\r\n                AutoLoginService,\r\n                JsrsAsignReducedService,\r\n                CurrentUrlService,\r\n                ClosestMatchingRouteService,\r\n            ],\r\n        };\r\n    }\r\n}\r\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, imports: [[CommonModule, HttpClientModule]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule, HttpClientModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nclass AutoLoginAllRoutesGuard {\r\n    constructor(autoLoginService, checkAuthService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        return this.checkAuthService.checkAuth().pipe(take(1), map(({ isAuthenticated }) => {\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n            }\r\n            if (!isAuthenticated) {\r\n                this.autoLoginService.saveRedirectRoute(configId, url);\r\n                this.loginService.login(configId);\r\n            }\r\n            return isAuthenticated;\r\n        }));\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginAllRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginAllRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginAllRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AutoLoginPartialRoutesGuard {\r\n    constructor(autoLoginService, authStateService, loginService, configurationProvider) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.authStateService = authStateService;\r\n        this.loginService = loginService;\r\n        this.configurationProvider = configurationProvider;\r\n    }\r\n    canLoad(route, segments) {\r\n        const routeToRedirect = segments.join('/');\r\n        return this.checkAuth(routeToRedirect);\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        const configId = this.getId();\r\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configId);\r\n        if (isAuthenticated) {\r\n            this.autoLoginService.checkSavedRedirectRouteAndNavigate(configId);\r\n        }\r\n        if (!isAuthenticated) {\r\n            this.autoLoginService.saveRedirectRoute(configId, url);\r\n            this.loginService.login(configId);\r\n        }\r\n        return isAuthenticated;\r\n    }\r\n    getId() {\r\n        return this.configurationProvider.getOpenIDConfiguration().configId;\r\n    }\r\n}\r\nAutoLoginPartialRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginPartialRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AutoLoginPartialRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationProvider }]; } });\n\nclass AuthInterceptor {\r\n    constructor(authStateService, configurationProvider, loggerService, closestMatchingRouteService) {\r\n        this.authStateService = authStateService;\r\n        this.configurationProvider = configurationProvider;\r\n        this.loggerService = loggerService;\r\n        this.closestMatchingRouteService = closestMatchingRouteService;\r\n    }\r\n    intercept(req, next) {\r\n        if (!this.configurationProvider.hasAsLeastOneConfig()) {\r\n            return next.handle(req);\r\n        }\r\n        const allConfigurations = this.configurationProvider.getAllConfigurations();\r\n        const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);\r\n        const allRoutesConfiguredFlat = [].concat.apply([], allRoutesConfigured);\r\n        if (allRoutesConfiguredFlat.length === 0) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `No routes to check configured`);\r\n            return next.handle(req);\r\n        }\r\n        const { matchingConfigId, matchingRoute } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url);\r\n        if (!matchingConfigId) {\r\n            const { configId } = allConfigurations[0];\r\n            this.loggerService.logDebug(configId, `Did not find any configured route for route ${req.url}`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}'`);\r\n        const token = this.authStateService.getAccessToken(matchingConfigId);\r\n        if (!token) {\r\n            this.loggerService.logDebug(matchingConfigId, `Wanted to add token to ${req.url} but found no token: '${token}'`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfigId, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\r\n        req = req.clone({\r\n            headers: req.headers.set('Authorization', 'Bearer ' + token),\r\n        });\r\n        return next.handle(req);\r\n    }\r\n}\r\nAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationProvider }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.0.4\", ngImport: i0, type: AuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationProvider }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });\n\n// Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, EventTypes, LogLevel, LoggerService, OidcConfigService, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, TokenHelperService, TokenValidationService, ValidationResult, configurationProviderFactory, createStaticLoader };\n"]},"metadata":{},"sourceType":"module"}